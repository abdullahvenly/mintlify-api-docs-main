---
title: "Retrieve Token Type Metadata"
description: "Comprehensive guide to retrieving NFT token type metadata with advanced parsing, validation, and metadata analysis tools"
icon: "file-magnifying-glass"
---

<Info>
**Metadata Retrieval:** Efficiently retrieve and analyze NFT token type metadata with advanced parsing, validation, and comprehensive metadata insights.

**Time required:** ~5 minutes
</Info>

## What is Token Type Metadata Retrieval?

Token type metadata retrieval allows you to fetch detailed metadata information for specific NFT templates, including images, descriptions, attributes, and contract details. This is essential for displaying NFT collections, analyzing template properties, and building comprehensive NFT applications with rich metadata support.

<CardGroup cols={2}>
  <Card title="Complete Metadata" icon="database">
    Retrieve full metadata including images, descriptions, and attributes
  </Card>
  <Card title="Contract Information" icon="file-contract">
    Access contract details and configuration data
  </Card>
  <Card title="Media Analysis" icon="image">
    Analyze images, animations, and media properties
  </Card>
  <Card title="Attribute Parsing" icon="tags">
    Parse and validate NFT attributes and traits
  </Card>
</CardGroup>

## Metadata Components

<Tabs>
  <Tab title="Basic Metadata">
    **Core Information:**
    - Name and description
    - Primary image and thumbnails
    - External links and references
    - Fungible/non-fungible classification
    
    **Use Cases:**
    - NFT gallery displays
    - Collection overviews
    - Basic NFT information
    - Template summaries
  </Tab>
  <Tab title="Media Assets">
    **Rich Media:**
    - High-resolution images
    - Animation URLs and videos
    - Preview and thumbnail variants
    - Media type classification
    
    **Use Cases:**
    - Rich NFT displays
    - Media galleries
    - Animation previews
    - Multi-format support
  </Tab>
  <Tab title="Attributes & Traits">
    **NFT Properties:**
    - Custom attributes and traits
    - Rarity indicators
    - System-generated properties
    - Trait type classifications
    
    **Use Cases:**
    - Rarity analysis
    - Filtering and sorting
    - Trait-based searches
    - Collection analytics
  </Tab>
</Tabs>

## Retrieve Token Type Metadata

<Steps>
  <Step title="Identify Token Type" icon="search">
    Specify the chain, contract address, and token type ID
    
    ```javascript
    const metadataRequest = {
      chain: 'MATIC',
      contractAddress: '0x30d6cff9cb268c59c75a94755b2c60e118d65657',
      tokenTypeId: 1
    };
    ```
  </Step>
  <Step title="Fetch Metadata" icon="download">
    Retrieve the complete metadata from the API
  </Step>
  <Step title="Parse & Validate" icon="check">
    Parse the metadata and validate required fields
  </Step>
  <Step title="Analyze Properties" icon="chart-line">
    Extract insights and analyze metadata properties
  </Step>
</Steps>

### API Implementation

<CodeGroup>
```javascript JavaScript
// Get token type metadata
const getTokenTypeMetadata = async (chain, contractAddress, tokenTypeId) => {
  try {
    const response = await fetch(`/api/v3/erc1155/contracts/${chain}/${contractAddress}/token-types/${tokenTypeId}/metadata`, {
      method: 'GET',
      headers: {
        'Authorization': 'Bearer YOUR_API_KEY',
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    
    if (data.success) {
      return data.result;
    } else {
      throw new Error('Failed to retrieve token type metadata');
    }
  } catch (error) {
    console.error('Error retrieving token type metadata:', error);
    throw error;
  }
};

// Enhanced metadata retrieval and analysis system
class TokenTypeMetadataManager {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.cache = new Map();
    this.cacheExpiry = new Map();
    this.defaultCacheTTL = 600000; // 10 minutes
    this.metadataAnalytics = new Map();
  }

  async getMetadata(chain, contractAddress, tokenTypeId, options = {}) {
    const {
      useCache = true,
      cacheTTL = this.defaultCacheTTL,
      validateMetadata = true,
      analyzeMedia = true,
      parseAttributes = true
    } = options;

    const cacheKey = `${chain}:${contractAddress}:${tokenTypeId}:metadata`;

    // Check cache first
    if (useCache && this.isCacheValid(cacheKey)) {
      console.log('Returning cached metadata');
      return this.cache.get(cacheKey);
    }

    try {
      const metadata = await getTokenTypeMetadata(chain, contractAddress, tokenTypeId);

      // Validate metadata structure
      if (validateMetadata) {
        this.validateMetadata(metadata);
      }

      // Analyze media assets
      if (analyzeMedia) {
        metadata.mediaAnalysis = await this.analyzeMediaAssets(metadata);
      }

      // Parse and enhance attributes
      if (parseAttributes) {
        metadata.attributeAnalysis = this.parseAttributes(metadata.attributes);
      }

      // Add metadata insights
      metadata.insights = this.generateMetadataInsights(metadata);

      // Cache the result
      if (useCache) {
        this.cache.set(cacheKey, metadata);
        this.cacheExpiry.set(cacheKey, Date.now() + cacheTTL);
      }

      // Record analytics
      this.recordMetadataAccess(chain, contractAddress, tokenTypeId);

      return metadata;
    } catch (error) {
      console.error(`Failed to retrieve metadata for token type ${tokenTypeId}:`, error);
      throw error;
    }
  }

  validateMetadata(metadata) {
    const errors = [];

    // Check required fields
    if (!metadata.name) {
      errors.push('Missing required field: name');
    }

    if (!metadata.image && !metadata.animationUrls?.length) {
      errors.push('Missing media: no image or animation URLs');
    }

    // Validate URLs
    const urlFields = ['image', 'imagePreview', 'imageThumbnail'];
    urlFields.forEach(field => {
      if (metadata[field] && !this.isValidUrl(metadata[field])) {
        errors.push(`Invalid URL in field: ${field}`);
      }
    });

    if (errors.length > 0) {
      console.warn('Metadata validation warnings:', errors);
    }

    return errors;
  }

  async analyzeMediaAssets(metadata) {
    const analysis = {
      hasImage: !!metadata.image,
      hasPreview: !!metadata.imagePreview,
      hasThumbnail: !!metadata.imageThumbnail,
      hasAnimations: metadata.animationUrls?.length > 0,
      mediaTypes: [],
      totalMediaAssets: 0,
      imageProperties: null,
      animationProperties: []
    };

    // Analyze image properties
    if (metadata.image) {
      analysis.imageProperties = await this.analyzeImageUrl(metadata.image);
      analysis.totalMediaAssets++;
    }

    // Analyze animation URLs
    if (metadata.animationUrls) {
      for (const animUrl of metadata.animationUrls) {
        const animProps = await this.analyzeAnimationUrl(animUrl);
        analysis.animationProperties.push(animProps);
        analysis.mediaTypes.push(animUrl.type || 'unknown');
        analysis.totalMediaAssets++;
      }
    }

    // Remove duplicates from media types
    analysis.mediaTypes = [...new Set(analysis.mediaTypes)];

    return analysis;
  }

  parseAttributes(attributes) {
    if (!attributes || !Array.isArray(attributes)) {
      return {
        total: 0,
        system: 0,
        custom: 0,
        traitTypes: [],
        attributeMap: {},
        rarityIndicators: []
      };
    }

    const analysis = {
      total: attributes.length,
      system: 0,
      custom: 0,
      traitTypes: [],
      attributeMap: {},
      rarityIndicators: []
    };

    attributes.forEach(attr => {
      // Count system vs custom attributes
      if (attr.type === 'system') {
        analysis.system++;
      } else {
        analysis.custom++;
      }

      // Collect trait types
      if (attr.traitType || attr.trait_type) {
        const traitType = attr.traitType || attr.trait_type;
        if (!analysis.traitTypes.includes(traitType)) {
          analysis.traitTypes.push(traitType);
        }
      }

      // Build attribute map
      const key = attr.name || attr.traitType || attr.trait_type;
      if (key) {
        analysis.attributeMap[key] = {
          value: attr.value,
          type: attr.type,
          traitType: attr.traitType || attr.trait_type
        };
      }

      // Identify potential rarity indicators
      if (this.isRarityIndicator(attr)) {
        analysis.rarityIndicators.push(attr);
      }
    });

    return analysis;
  }

  generateMetadataInsights(metadata) {
    const insights = {
      completeness: this.calculateCompletenessScore(metadata),
      mediaRichness: this.calculateMediaRichness(metadata),
      attributeComplexity: this.calculateAttributeComplexity(metadata),
      qualityScore: 0,
      recommendations: []
    };

    // Calculate overall quality score
    insights.qualityScore = Math.round(
      (insights.completeness + insights.mediaRichness + insights.attributeComplexity) / 3
    );

    // Generate recommendations
    insights.recommendations = this.generateRecommendations(metadata, insights);

    return insights;
  }

  calculateCompletenessScore(metadata) {
    let score = 0;
    const maxScore = 100;

    // Required fields
    if (metadata.name) score += 20;
    if (metadata.description) score += 15;
    if (metadata.image) score += 20;

    // Optional but valuable fields
    if (metadata.imagePreview) score += 10;
    if (metadata.imageThumbnail) score += 10;
    if (metadata.animationUrls?.length > 0) score += 15;
    if (metadata.attributes?.length > 0) score += 10;

    return Math.min(score, maxScore);
  }

  calculateMediaRichness(metadata) {
    let score = 0;

    if (metadata.image) score += 30;
    if (metadata.imagePreview) score += 20;
    if (metadata.imageThumbnail) score += 20;
    if (metadata.animationUrls?.length > 0) score += 30;

    return Math.min(score, 100);
  }

  calculateAttributeComplexity(metadata) {
    if (!metadata.attributes) return 0;

    const customAttributes = metadata.attributes.filter(attr => attr.type !== 'system');
    const uniqueTraitTypes = new Set(
      metadata.attributes.map(attr => attr.traitType || attr.trait_type).filter(Boolean)
    );

    let score = 0;
    score += Math.min(customAttributes.length * 10, 50); // Up to 50 for custom attributes
    score += Math.min(uniqueTraitTypes.size * 15, 50);   // Up to 50 for trait diversity

    return Math.min(score, 100);
  }

  generateRecommendations(metadata, insights) {
    const recommendations = [];

    if (!metadata.description) {
      recommendations.push({
        type: 'missing_field',
        priority: 'medium',
        message: 'Add a description to improve metadata completeness'
      });
    }

    if (!metadata.imagePreview) {
      recommendations.push({
        type: 'missing_media',
        priority: 'low',
        message: 'Consider adding preview images for better display'
      });
    }

    if (!metadata.attributes || metadata.attributes.length === 0) {
      recommendations.push({
        type: 'missing_attributes',
        priority: 'medium',
        message: 'Add attributes to enhance NFT properties and searchability'
      });
    }

    if (insights.qualityScore < 70) {
      recommendations.push({
        type: 'quality_improvement',
        priority: 'high',
        message: 'Metadata quality is below recommended standards'
      });
    }

    return recommendations;
  }

  // Utility methods
  isValidUrl(url) {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  async analyzeImageUrl(imageUrl) {
    try {
      const url = new URL(imageUrl);
      const pathname = url.pathname;
      const extension = pathname.split('.').pop()?.toLowerCase();
      
      return {
        url: imageUrl,
        extension,
        format: this.getImageFormat(extension),
        isValid: this.isValidImageExtension(extension),
        domain: url.hostname,
        path: pathname
      };
    } catch (error) {
      return {
        url: imageUrl,
        isValid: false,
        error: error.message
      };
    }
  }

  async analyzeAnimationUrl(animationUrl) {
    try {
      const url = new URL(animationUrl.value);
      const pathname = url.pathname;
      const extension = pathname.split('.').pop()?.toLowerCase();
      
      return {
        type: animationUrl.type,
        url: animationUrl.value,
        extension,
        format: this.getMediaFormat(extension),
        isValid: this.isValidMediaExtension(extension),
        domain: url.hostname,
        path: pathname
      };
    } catch (error) {
      return {
        type: animationUrl.type,
        url: animationUrl.value,
        isValid: false,
        error: error.message
      };
    }
  }

  getImageFormat(extension) {
    const formats = {
      'jpg': 'JPEG',
      'jpeg': 'JPEG',
      'png': 'PNG',
      'gif': 'GIF',
      'svg': 'SVG',
      'webp': 'WebP'
    };
    return formats[extension] || 'Unknown';
  }

  getMediaFormat(extension) {
    const formats = {
      'mp4': 'MP4 Video',
      'webm': 'WebM Video',
      'mov': 'QuickTime Video',
      'mp3': 'MP3 Audio',
      'wav': 'WAV Audio',
      'ogg': 'OGG Audio'
    };
    return formats[extension] || 'Unknown';
  }

  isValidImageExtension(extension) {
    const validExtensions = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp'];
    return validExtensions.includes(extension?.toLowerCase());
  }

  isValidMediaExtension(extension) {
    const validExtensions = ['mp4', 'webm', 'mov', 'mp3', 'wav', 'ogg'];
    return validExtensions.includes(extension?.toLowerCase());
  }

  isRarityIndicator(attribute) {
    const rarityKeywords = ['rarity', 'rare', 'legendary', 'epic', 'common', 'uncommon'];
    const name = (attribute.name || '').toLowerCase();
    const traitType = (attribute.traitType || attribute.trait_type || '').toLowerCase();
    
    return rarityKeywords.some(keyword => 
      name.includes(keyword) || traitType.includes(keyword)
    );
  }

  isCacheValid(key) {
    if (!this.cache.has(key) || !this.cacheExpiry.has(key)) {
      return false;
    }
    return Date.now() < this.cacheExpiry.get(key);
  }

  recordMetadataAccess(chain, contractAddress, tokenTypeId) {
    const key = `${chain}:${contractAddress}:${tokenTypeId}`;
    
    if (!this.metadataAnalytics.has(key)) {
      this.metadataAnalytics.set(key, {
        accessCount: 0,
        firstAccess: new Date().toISOString(),
        lastAccess: null
      });
    }
    
    const analytics = this.metadataAnalytics.get(key);
    analytics.accessCount++;
    analytics.lastAccess = new Date().toISOString();
  }

  generateMetadataReport(chain, contractAddress, tokenTypeId) {
    const analyticsKey = `${chain}:${contractAddress}:${tokenTypeId}`;
    const analytics = this.metadataAnalytics.get(analyticsKey);
    
    return {
      chain,
      contractAddress,
      tokenTypeId,
      analytics: analytics || { accessCount: 0 },
      cacheStatus: this.isCacheValid(`${analyticsKey}:metadata`) ? 'cached' : 'not_cached',
      lastRetrieved: new Date().toISOString()
    };
  }
}

// Usage examples
const metadataManager = new TokenTypeMetadataManager('YOUR_API_KEY');

// Get metadata with full analysis
const metadata = await metadataManager.getMetadata(
  'MATIC',
  '0x30d6cff9cb268c59c75a94755b2c60e118d65657',
  1,
  {
    useCache: true,
    validateMetadata: true,
    analyzeMedia: true,
    parseAttributes: true
  }
);

console.log('Metadata:', metadata);
console.log('Media Analysis:', metadata.mediaAnalysis);
console.log('Attribute Analysis:', metadata.attributeAnalysis);
console.log('Insights:', metadata.insights);
```

```python Python
import requests
import re
from urllib.parse import urlparse
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta

class TokenTypeMetadataManager:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = '/api/v3/erc1155'
        self.cache = {}
        self.cache_expiry = {}
        self.default_cache_ttl = 600  # 10 minutes
        self.metadata_analytics = {}
    
    def get_token_type_metadata(self, chain: str, contract_address: str, token_type_id: int) -> Dict[str, Any]:
        """Get token type metadata"""
        url = f'{self.base_url}/contracts/{chain}/{contract_address}/token-types/{token_type_id}/metadata'
        headers = {
            'Authorization': f'Bearer {self.api_key}',
            'Content-Type': 'application/json'
        }
        
        try:
            response = requests.get(url, headers=headers)
            response.raise_for_status()
            
            data = response.json()
            
            if data.get('success'):
                return data['result']
            else:
                raise Exception('Failed to retrieve token type metadata')
                
        except requests.exceptions.RequestException as error:
            print(f'Error retrieving token type metadata: {error}')
            raise error
    
    def get_metadata(self, chain: str, contract_address: str, token_type_id: int, 
                    options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Get metadata with caching and analysis"""
        if options is None:
            options = {}
        
        use_cache = options.get('use_cache', True)
        cache_ttl = options.get('cache_ttl', self.default_cache_ttl)
        validate_metadata = options.get('validate_metadata', True)
        analyze_media = options.get('analyze_media', True)
        parse_attributes = options.get('parse_attributes', True)
        
        cache_key = f"{chain}:{contract_address}:{token_type_id}:metadata"
        
        # Check cache first
        if use_cache and self._is_cache_valid(cache_key):
            print('Returning cached metadata')
            return self.cache[cache_key]
        
        try:
            metadata = self.get_token_type_metadata(chain, contract_address, token_type_id)
            
            # Validate metadata structure
            if validate_metadata:
                self.validate_metadata(metadata)
            
            # Analyze media assets
            if analyze_media:
                metadata['media_analysis'] = self.analyze_media_assets(metadata)
            
            # Parse and enhance attributes
            if parse_attributes:
                metadata['attribute_analysis'] = self.parse_attributes(metadata.get('attributes', []))
            
            # Add metadata insights
            metadata['insights'] = self.generate_metadata_insights(metadata)
            
            # Cache the result
            if use_cache:
                self.cache[cache_key] = metadata
                self.cache_expiry[cache_key] = datetime.now() + timedelta(seconds=cache_ttl)
            
            # Record analytics
            self._record_metadata_access(chain, contract_address, token_type_id)
            
            return metadata
            
        except Exception as error:
            print(f'Failed to retrieve metadata for token type {token_type_id}: {error}')
            raise error
    
    def validate_metadata(self, metadata: Dict[str, Any]) -> List[str]:
        """Validate metadata structure"""
        errors = []
        
        # Check required fields
        if not metadata.get('name'):
            errors.append('Missing required field: name')
        
        if not metadata.get('image') and not metadata.get('animationUrls'):
            errors.append('Missing media: no image or animation URLs')
        
        # Validate URLs
        url_fields = ['image', 'imagePreview', 'imageThumbnail']
        for field in url_fields:
            if metadata.get(field) and not self._is_valid_url(metadata[field]):
                errors.append(f'Invalid URL in field: {field}')
        
        if errors:
            print('Metadata validation warnings:', errors)
        
        return errors
    
    def analyze_media_assets(self, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze media assets in metadata"""
        analysis = {
            'has_image': bool(metadata.get('image')),
            'has_preview': bool(metadata.get('imagePreview')),
            'has_thumbnail': bool(metadata.get('imageThumbnail')),
            'has_animations': bool(metadata.get('animationUrls')),
            'media_types': [],
            'total_media_assets': 0,
            'image_properties': None,
            'animation_properties': []
        }
        
        # Analyze image properties
        if metadata.get('image'):
            analysis['image_properties'] = self._analyze_image_url(metadata['image'])
            analysis['total_media_assets'] += 1
        
        # Analyze animation URLs
        if metadata.get('animationUrls'):
            for anim_url in metadata['animationUrls']:
                anim_props = self._analyze_animation_url(anim_url)
                analysis['animation_properties'].append(anim_props)
                if anim_url.get('type'):
                    analysis['media_types'].append(anim_url['type'])
                analysis['total_media_assets'] += 1
        
        # Remove duplicates from media types
        analysis['media_types'] = list(set(analysis['media_types']))
        
        return analysis
    
    def parse_attributes(self, attributes: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Parse and analyze attributes"""
        if not attributes:
            return {
                'total': 0,
                'system': 0,
                'custom': 0,
                'trait_types': [],
                'attribute_map': {},
                'rarity_indicators': []
            }
        
        analysis = {
            'total': len(attributes),
            'system': 0,
            'custom': 0,
            'trait_types': [],
            'attribute_map': {},
            'rarity_indicators': []
        }
        
        for attr in attributes:
            # Count system vs custom attributes
            if attr.get('type') == 'system':
                analysis['system'] += 1
            else:
                analysis['custom'] += 1
            
            # Collect trait types
            trait_type = attr.get('traitType') or attr.get('trait_type')
            if trait_type and trait_type not in analysis['trait_types']:
                analysis['trait_types'].append(trait_type)
            
            # Build attribute map
            key = attr.get('name') or trait_type
            if key:
                analysis['attribute_map'][key] = {
                    'value': attr.get('value'),
                    'type': attr.get('type'),
                    'trait_type': trait_type
                }
            
            # Identify potential rarity indicators
            if self._is_rarity_indicator(attr):
                analysis['rarity_indicators'].append(attr)
        
        return analysis
    
    def generate_metadata_insights(self, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """Generate metadata insights and recommendations"""
        insights = {
            'completeness': self._calculate_completeness_score(metadata),
            'media_richness': self._calculate_media_richness(metadata),
            'attribute_complexity': self._calculate_attribute_complexity(metadata),
            'quality_score': 0,
            'recommendations': []
        }
        
        # Calculate overall quality score
        insights['quality_score'] = round(
            (insights['completeness'] + insights['media_richness'] + insights['attribute_complexity']) / 3
        )
        
        # Generate recommendations
        insights['recommendations'] = self._generate_recommendations(metadata, insights)
        
        return insights
    
    def _calculate_completeness_score(self, metadata: Dict[str, Any]) -> int:
        """Calculate metadata completeness score"""
        score = 0
        
        if metadata.get('name'): score += 20
        if metadata.get('description'): score += 15
        if metadata.get('image'): score += 20
        if metadata.get('imagePreview'): score += 10
        if metadata.get('imageThumbnail'): score += 10
        if metadata.get('animationUrls'): score += 15
        if metadata.get('attributes'): score += 10
        
        return min(score, 100)
    
    def _calculate_media_richness(self, metadata: Dict[str, Any]) -> int:
        """Calculate media richness score"""
        score = 0
        
        if metadata.get('image'): score += 30
        if metadata.get('imagePreview'): score += 20
        if metadata.get('imageThumbnail'): score += 20
        if metadata.get('animationUrls'): score += 30
        
        return min(score, 100)
    
    def _calculate_attribute_complexity(self, metadata: Dict[str, Any]) -> int:
        """Calculate attribute complexity score"""
        attributes = metadata.get('attributes', [])
        if not attributes:
            return 0
        
        custom_attributes = [attr for attr in attributes if attr.get('type') != 'system']
        unique_trait_types = set()
        
        for attr in attributes:
            trait_type = attr.get('traitType') or attr.get('trait_type')
            if trait_type:
                unique_trait_types.add(trait_type)
        
        score = 0
        score += min(len(custom_attributes) * 10, 50)  # Up to 50 for custom attributes
        score += min(len(unique_trait_types) * 15, 50)  # Up to 50 for trait diversity
        
        return min(score, 100)
    
    def _generate_recommendations(self, metadata: Dict[str, Any], insights: Dict[str, Any]) -> List[Dict[str, str]]:
        """Generate improvement recommendations"""
        recommendations = []
        
        if not metadata.get('description'):
            recommendations.append({
                'type': 'missing_field',
                'priority': 'medium',
                'message': 'Add a description to improve metadata completeness'
            })
        
        if not metadata.get('imagePreview'):
            recommendations.append({
                'type': 'missing_media',
                'priority': 'low',
                'message': 'Consider adding preview images for better display'
            })
        
        if not metadata.get('attributes'):
            recommendations.append({
                'type': 'missing_attributes',
                'priority': 'medium',
                'message': 'Add attributes to enhance NFT properties and searchability'
            })
        
        if insights['quality_score'] < 70:
            recommendations.append({
                'type': 'quality_improvement',
                'priority': 'high',
                'message': 'Metadata quality is below recommended standards'
            })
        
        return recommendations
    
    def _is_valid_url(self, url: str) -> bool:
        """Check if URL is valid"""
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc])
        except:
            return False
    
    def _analyze_image_url(self, image_url: str) -> Dict[str, Any]:
        """Analyze image URL properties"""
        try:
            parsed = urlparse(image_url)
            extension = parsed.path.split('.')[-1].lower() if '.' in parsed.path else None
            
            return {
                'url': image_url,
                'extension': extension,
                'format': self._get_image_format(extension),
                'is_valid': self._is_valid_image_extension(extension),
                'domain': parsed.hostname,
                'path': parsed.path
            }
        except Exception as error:
            return {
                'url': image_url,
                'is_valid': False,
                'error': str(error)
            }
    
    def _analyze_animation_url(self, animation_url: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze animation URL properties"""
        try:
            url = animation_url.get('value', '')
            parsed = urlparse(url)
            extension = parsed.path.split('.')[-1].lower() if '.' in parsed.path else None
            
            return {
                'type': animation_url.get('type'),
                'url': url,
                'extension': extension,
                'format': self._get_media_format(extension),
                'is_valid': self._is_valid_media_extension(extension),
                'domain': parsed.hostname,
                'path': parsed.path
            }
        except Exception as error:
            return {
                'type': animation_url.get('type'),
                'url': animation_url.get('value', ''),
                'is_valid': False,
                'error': str(error)
            }
    
    def _get_image_format(self, extension: str) -> str:
        """Get image format from extension"""
        formats = {
            'jpg': 'JPEG',
            'jpeg': 'JPEG',
            'png': 'PNG',
            'gif': 'GIF',
            'svg': 'SVG',
            'webp': 'WebP'
        }
        return formats.get(extension, 'Unknown')
    
    def _get_media_format(self, extension: str) -> str:
        """Get media format from extension"""
        formats = {
            'mp4': 'MP4 Video',
            'webm': 'WebM Video',
            'mov': 'QuickTime Video',
            'mp3': 'MP3 Audio',
            'wav': 'WAV Audio',
            'ogg': 'OGG Audio'
        }
        return formats.get(extension, 'Unknown')
    
    def _is_valid_image_extension(self, extension: str) -> bool:
        """Check if image extension is valid"""
        valid_extensions = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp']
        return extension.lower() in valid_extensions if extension else False
    
    def _is_valid_media_extension(self, extension: str) -> bool:
        """Check if media extension is valid"""
        valid_extensions = ['mp4', 'webm', 'mov', 'mp3', 'wav', 'ogg']
        return extension.lower() in valid_extensions if extension else False
    
    def _is_rarity_indicator(self, attribute: Dict[str, Any]) -> bool:
        """Check if attribute is a rarity indicator"""
        rarity_keywords = ['rarity', 'rare', 'legendary', 'epic', 'common', 'uncommon']
        name = (attribute.get('name') or '').lower()
        trait_type = (attribute.get('traitType') or attribute.get('trait_type') or '').lower()
        
        return any(keyword in name or keyword in trait_type for keyword in rarity_keywords)
    
    def _is_cache_valid(self, key: str) -> bool:
        """Check if cache entry is valid"""
        if key not in self.cache or key not in self.cache_expiry:
            return False
        return datetime.now() < self.cache_expiry[key]
    
    def _record_metadata_access(self, chain: str, contract_address: str, token_type_id: int):
        """Record metadata access for analytics"""
        key = f"{chain}:{contract_address}:{token_type_id}"
        
        if key not in self.metadata_analytics:
            self.metadata_analytics[key] = {
                'access_count': 0,
                'first_access': datetime.now().isoformat(),
                'last_access': None
            }
        
        self.metadata_analytics[key]['access_count'] += 1
        self.metadata_analytics[key]['last_access'] = datetime.now().isoformat()

# Usage
metadata_manager = TokenTypeMetadataManager('YOUR_API_KEY')

# Get metadata with analysis
metadata = metadata_manager.get_metadata(
    'MATIC',
    '0x30d6cff9cb268c59c75a94755b2c60e118d65657',
    1,
    {
        'use_cache': True,
        'validate_metadata': True,
        'analyze_media': True,
        'parse_attributes': True
    }
)

print('Metadata:', metadata)
```

```bash cURL
# Get token type metadata
curl -X GET '/api/v3/erc1155/contracts/MATIC/0x30d6cff9cb268c59c75a94755b2c60e118d65657/token-types/1/metadata' \
  -H 'Authorization: Bearer YOUR_API_KEY' \
  -H 'Content-Type: application/json'

# Get metadata with formatted output
curl -X GET '/api/v3/erc1155/contracts/MATIC/0x30d6cff9cb268c59c75a94755b2c60e118d65657/token-types/1/metadata' \
  -H 'Authorization: Bearer YOUR_API_KEY' \
  -H 'Content-Type: application/json' \
  -s | jq '.'

# Batch retrieve multiple token type metadata
#!/bin/bash
CONTRACT_ADDRESS="0x30d6cff9cb268c59c75a94755b2c60e118d65657"
CHAIN="MATIC"
TOKEN_TYPE_IDS=(1 2 3 4 5)

for token_type_id in "${TOKEN_TYPE_IDS[@]}"; do
  echo "Retrieving metadata for token type $token_type_id..."
  curl -X GET "/api/v3/erc1155/contracts/$CHAIN/$CONTRACT_ADDRESS/token-types/$token_type_id/metadata" \
    -H 'Authorization: Bearer YOUR_API_KEY' \
    -H 'Content-Type: application/json' \
    -s | jq '.result' > "token_type_${token_type_id}_metadata.json"
  echo "Saved to token_type_${token_type_id}_metadata.json"
  sleep 0.5  # Rate limiting
done
```

```php PHP
<?php
class TokenTypeMetadataManager {
    private $apiKey;
    private $baseUrl;
    private $cache;
    private $cacheExpiry;
    private $defaultCacheTTL;
    
    public function __construct($apiKey, $baseUrl = '/api/v3/erc1155') {
        $this->apiKey = $apiKey;
        $this->baseUrl = $baseUrl;
        $this->cache = [];
        $this->cacheExpiry = [];
        $this->defaultCacheTTL = 600; // 10 minutes
    }
    
    public function getMetadata($chain, $contractAddress, $tokenTypeId, $options = []) {
        $useCache = $options['useCache'] ?? true;
        $cacheTTL = $options['cacheTTL'] ?? $this->defaultCacheTTL;
        $validateMetadata = $options['validateMetadata'] ?? true;
        $analyzeMedia = $options['analyzeMedia'] ?? true;
        $parseAttributes = $options['parseAttributes'] ?? true;
        
        $cacheKey = "{$chain}:{$contractAddress}:{$tokenTypeId}:metadata";
        
        // Check cache first
        if ($useCache && $this->isCacheValid($cacheKey)) {
            echo "Returning cached metadata\n";
            return $this->cache[$cacheKey];
        }
        
        try {
            $metadata = $this->getTokenTypeMetadata($chain, $contractAddress, $tokenTypeId);
            
            // Validate metadata structure
            if ($validateMetadata) {
                $this->validateMetadata($metadata);
            }
            
            // Analyze media assets
            if ($analyzeMedia) {
                $metadata['mediaAnalysis'] = $this->analyzeMediaAssets($metadata);
            }
            
            // Parse and enhance attributes
            if ($parseAttributes) {
                $metadata['attributeAnalysis'] = $this->parseAttributes($metadata['attributes'] ?? []);
            }
            
            // Add metadata insights
            $metadata['insights'] = $this->generateMetadataInsights($metadata);
            
            // Cache the result
            if ($useCache) {
                $this->cache[$cacheKey] = $metadata;
                $this->cacheExpiry[$cacheKey] = time() + $cacheTTL;
            }
            
            return $metadata;
            
        } catch (Exception $error) {
            echo "Failed to retrieve metadata for token type {$tokenTypeId}: " . $error->getMessage() . "\n";
            throw $error;
        }
    }
    
    private function getTokenTypeMetadata($chain, $contractAddress, $tokenTypeId) {
        $url = "{$this->baseUrl}/contracts/{$chain}/{$contractAddress}/token-types/{$tokenTypeId}/metadata";
        
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            "Authorization: Bearer {$this->apiKey}",
            'Content-Type: application/json'
        ]);
        
        $response = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);
        
        if ($httpCode !== 200) {
            throw new Exception("HTTP {$httpCode}: Failed to retrieve token type metadata");
        }
        
        $data = json_decode($response, true);
        
        if (!$data['success']) {
            throw new Exception('Failed to retrieve token type metadata');
        }
        
        return $data['result'];
    }
    
    private function validateMetadata($metadata) {
        $errors = [];
        
        if (empty($metadata['name'])) {
            $errors[] = 'Missing required field: name';
        }
        
        if (empty($metadata['image']) && empty($metadata['animationUrls'])) {
            $errors[] = 'Missing media: no image or animation URLs';
        }
        
        if (!empty($errors)) {
            echo "Metadata validation warnings: " . implode(', ', $errors) . "\n";
        }
        
        return $errors;
    }
    
    private function analyzeMediaAssets($metadata) {
        return [
            'hasImage' => !empty($metadata['image']),
            'hasPreview' => !empty($metadata['imagePreview']),
            'hasThumbnail' => !empty($metadata['imageThumbnail']),
            'hasAnimations' => !empty($metadata['animationUrls']),
            'totalMediaAssets' => (int)!empty($metadata['image']) + count($metadata['animationUrls'] ?? [])
        ];
    }
    
    private function parseAttributes($attributes) {
        if (empty($attributes)) {
            return [
                'total' => 0,
                'system' => 0,
                'custom' => 0,
                'traitTypes' => []
            ];
        }
        
        $analysis = [
            'total' => count($attributes),
            'system' => 0,
            'custom' => 0,
            'traitTypes' => []
        ];
        
        foreach ($attributes as $attr) {
            if (($attr['type'] ?? '') === 'system') {
                $analysis['system']++;
            } else {
                $analysis['custom']++;
            }
            
            $traitType = $attr['traitType'] ?? $attr['trait_type'] ?? null;
            if ($traitType && !in_array($traitType, $analysis['traitTypes'])) {
                $analysis['traitTypes'][] = $traitType;
            }
        }
        
        return $analysis;
    }
    
    private function generateMetadataInsights($metadata) {
        $completeness = $this->calculateCompletenessScore($metadata);
        $mediaRichness = $this->calculateMediaRichness($metadata);
        $attributeComplexity = $this->calculateAttributeComplexity($metadata);
        
        return [
            'completeness' => $completeness,
            'mediaRichness' => $mediaRichness,
            'attributeComplexity' => $attributeComplexity,
            'qualityScore' => round(($completeness + $mediaRichness + $attributeComplexity) / 3),
            'recommendations' => $this->generateRecommendations($metadata)
        ];
    }
    
    private function calculateCompletenessScore($metadata) {
        $score = 0;
        
        if (!empty($metadata['name'])) $score += 20;
        if (!empty($metadata['description'])) $score += 15;
        if (!empty($metadata['image'])) $score += 20;
        if (!empty($metadata['imagePreview'])) $score += 10;
        if (!empty($metadata['imageThumbnail'])) $score += 10;
        if (!empty($metadata['animationUrls'])) $score += 15;
        if (!empty($metadata['attributes'])) $score += 10;
        
        return min($score, 100);
    }
    
    private function calculateMediaRichness($metadata) {
        $score = 0;
        
        if (!empty($metadata['image'])) $score += 30;
        if (!empty($metadata['imagePreview'])) $score += 20;
        if (!empty($metadata['imageThumbnail'])) $score += 20;
        if (!empty($metadata['animationUrls'])) $score += 30;
        
        return min($score, 100);
    }
    
    private function calculateAttributeComplexity($metadata) {
        $attributes = $metadata['attributes'] ?? [];
        if (empty($attributes)) return 0;
        
        $customAttributes = array_filter($attributes, function($attr) {
            return ($attr['type'] ?? '') !== 'system';
        });
        
        $traitTypes = [];
        foreach ($attributes as $attr) {
            $traitType = $attr['traitType'] ?? $attr['trait_type'] ?? null;
            if ($traitType && !in_array($traitType, $traitTypes)) {
                $traitTypes[] = $traitType;
            }
        }
        
        $score = 0;
        $score += min(count($customAttributes) * 10, 50);  // Up to 50 for custom attributes
        $score += min(count($traitTypes) * 15, 50);        // Up to 50 for trait diversity
        
        return min($score, 100);
    }
    
    private function generateRecommendations($metadata) {
        $recommendations = [];
        
        if (empty($metadata['description'])) {
            $recommendations[] = 'Add a description to improve metadata completeness';
        }
        
        if (empty($metadata['imagePreview'])) {
            $recommendations[] = 'Consider adding preview images for better display';
        }
        
        if (empty($metadata['attributes'])) {
            $recommendations[] = 'Add attributes to enhance NFT properties and searchability';
        }
        
        return $recommendations;
    }
    
    private function isCacheValid($key) {
        return isset($this->cache[$key]) && 
               isset($this->cacheExpiry[$key]) && 
               time() < $this->cacheExpiry[$key];
    }
}

// Usage
$metadataManager = new TokenTypeMetadataManager('YOUR_API_KEY');

try {
    $metadata = $metadataManager->getMetadata(
        'MATIC',
        '0x30d6cff9cb268c59c75a94755b2c60e118d65657',
        1,
        [
            'useCache' => true,
            'validateMetadata' => true,
            'analyzeMedia' => true,
            'parseAttributes' => true
        ]
    );
    
    echo "Token Type Metadata: " . json_encode($metadata, JSON_PRETTY_PRINT) . "\n";
    
} catch (Exception $e) {
    echo "Error: " . $e->getMessage() . "\n";
}
?>
```
</CodeGroup>

## Best Practices

<Tip>
**Token Type Metadata Best Practices:**

1. **Complete Information** - Ensure all required fields are populated with meaningful data
2. **Media Quality** - Use high-resolution images and proper media formats
3. **Attribute Structure** - Organize attributes with clear trait types and values
4. **Validation** - Always validate URLs and metadata structure before processing
5. **Caching Strategy** - Implement intelligent caching to improve performance
6. **Error Handling** - Handle missing or invalid metadata gracefully
7. **Analytics Tracking** - Monitor metadata access patterns for optimization
8. **Regular Updates** - Keep metadata current and accurate for better user experience
</Tip>

## What's Next?

<CardGroup cols={2}>
  <Card title="Update Token Type Metadata" href="/guides/nft-api/metadata/update-token-type-metadata" icon="edit">
    Learn how to update token type metadata
  </Card>
  <Card title="NFT Metadata" href="/guides/nft-api/metadata/retrieve-nft-metadata" icon="file-text">
    Retrieve individual NFT metadata
  </Card>
  <Card title="Token Type Management" href="/guides/nft-api/token-types/retrieve-token-types" icon="layer-group">
    Comprehensive token type management
  </Card>
  <Card title="API Reference" href="/api-reference/NFT-API/token-type-metadata/get-token-type-metadata" icon="book">
    Explore the complete token type metadata API documentation
  </Card>
</CardGroup>
