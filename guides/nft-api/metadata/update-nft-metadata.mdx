---
title: "Update NFT Metadata"
description: "Comprehensive guide to updating individual NFT metadata with dynamic NFT capabilities, validation, and advanced property management"
icon: "pen-nib"
---

<Info>
**Dynamic NFT Updates:** Update individual NFT metadata properties with comprehensive validation, change tracking, and advanced management systems for dynamic NFTs.

**Time required:** ~8 minutes
</Info>

## What is NFT Metadata Updating?

NFT metadata updating enables dynamic NFTs by allowing you to modify specific properties of already minted NFTs. This includes updating names, descriptions, images, background colors, and external URLs at the individual token level. Essential for creating evolving NFTs, fixing errors, and building interactive NFT experiences.

<CardGroup cols={2}>
  <Card title="Dynamic NFTs" icon="arrows-rotate">
    Create evolving NFTs that change over time
  </Card>
  <Card title="Property Updates" icon="sliders">
    Update specific metadata properties individually
  </Card>
  <Card title="Validation & Safety" icon="shield-check">
    Comprehensive validation and change tracking
  </Card>
  <Card title="Batch Operations" icon="layer-group">
    Update multiple NFTs efficiently
  </Card>
</CardGroup>

## Dynamic NFT Capabilities

<Tabs>
  <Tab title="Updatable Properties">
    **Modifiable Fields:**
    - `name` - NFT name
    - `description` - NFT description
    - `image` - Primary image URL
    - `backgroundColor` - Background color
    - `externalUrl` - External link
    
    **Use Cases:**
    - Gaming NFTs with evolving stats
    - Seasonal NFT updates
    - Progressive reveal mechanics
    - Interactive storytelling
  </Tab>
  <Tab title="Dynamic Scenarios">
    **Common Use Cases:**
    - **Gaming NFTs:** Update stats, levels, equipment
    - **Collectibles:** Seasonal themes, special events
    - **Art NFTs:** Progressive reveals, time-based changes
    - **Utility NFTs:** Status updates, membership levels
    
    **Benefits:**
    - Enhanced user engagement
    - Increased NFT utility
    - Interactive experiences
    - Long-term value retention
  </Tab>
  <Tab title="Best Practices">
    **Update Guidelines:**
    - Plan dynamic elements in advance
    - Validate all property changes
    - Track update history
    - Communicate changes to holders
    
    **Technical Considerations:**
    - Property names are case-sensitive
    - URLs must be valid and accessible
    - Consider gas costs for updates
    - Implement proper access controls
  </Tab>
</Tabs>

## Update NFT Metadata

<Steps>
  <Step title="Identify Target NFT" icon="crosshairs">
    Specify the chain, contract address, and token ID
    
    ```javascript
    const nftTarget = {
      chain: 'MATIC',
      contractAddress: '0x127653794299145470e973cf68da9983f576f266',
      tokenId: 3
    };
    ```
  </Step>
  <Step title="Choose Property" icon="list">
    Select the property to update (name, description, image, etc.)
  </Step>
  <Step title="Prepare New Value" icon="edit">
    Prepare and validate the new property value
  </Step>
  <Step title="Execute Update" icon="paper-plane">
    Send the update request to the API
  </Step>
</Steps>

### API Implementation

<CodeGroup>
```javascript JavaScript
// Update NFT metadata property
const updateNFTProperty = async (chain, contractAddress, tokenId, propertyName, value) => {
  try {
    const response = await fetch(`/api/v3/erc1155/contracts/${chain}/${contractAddress}/tokens/${tokenId}/metadata/${propertyName}`, {
      method: 'PUT',
      headers: {
        'Authorization': 'Bearer YOUR_API_KEY',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ value })
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    
    if (data.success) {
      return data.result;
    } else {
      throw new Error('Failed to update NFT property');
    }
  } catch (error) {
    console.error('Error updating NFT property:', error);
    throw error;
  }
};

// Enhanced dynamic NFT metadata management system
class DynamicNFTManager {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.updateHistory = new Map();
    this.validationRules = new Map();
    this.changeTracking = new Map();
    this.scheduledUpdates = new Map();
  }

  async updateProperty(chain, contractAddress, tokenId, propertyName, value, options = {}) {
    const {
      validateBeforeUpdate = true,
      trackChanges = true,
      dryRun = false,
      reason = null
    } = options;

    const nftKey = `${chain}:${contractAddress}:${tokenId}`;

    try {
      // Validate property and value
      if (validateBeforeUpdate) {
        const validation = this.validatePropertyUpdate(propertyName, value);
        if (!validation.isValid) {
          throw new Error(`Validation failed: ${validation.errors.join(', ')}`);
        }
      }

      // Dry run mode - validate without updating
      if (dryRun) {
        return {
          success: true,
          dryRun: true,
          validation: this.validatePropertyUpdate(propertyName, value),
          estimatedImpact: this.estimateUpdateImpact(propertyName, value),
          message: 'Dry run completed successfully'
        };
      }

      // Get current metadata for comparison
      const currentMetadata = await this.getCurrentMetadata(chain, contractAddress, tokenId);
      const oldValue = currentMetadata[propertyName];

      // Execute the update
      const result = await updateNFTProperty(chain, contractAddress, tokenId, propertyName, value);

      // Track changes if requested
      if (trackChanges) {
        this.recordPropertyChange(nftKey, propertyName, oldValue, value, reason);
      }

      return {
        success: true,
        result,
        nftKey,
        propertyName,
        oldValue,
        newValue: value,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error(`Failed to update ${propertyName} for NFT ${nftKey}:`, error);
      throw error;
    }
  }

  async batchUpdateProperties(updates, options = {}) {
    const {
      concurrency = 3,
      continueOnError = false,
      validateAll = true,
      delayBetweenUpdates = 1000
    } = options;

    const results = [];
    const errors = [];

    // Validate all updates first if requested
    if (validateAll) {
      for (const update of updates) {
        const validation = this.validatePropertyUpdate(update.propertyName, update.value);
        if (!validation.isValid) {
          const error = {
            update,
            error: `Validation failed: ${validation.errors.join(', ')}`
          };
          
          if (!continueOnError) {
            throw new Error(`Batch validation failed: ${error.error}`);
          }
          
          errors.push(error);
        }
      }
    }

    // Process updates in batches
    for (let i = 0; i < updates.length; i += concurrency) {
      const batch = updates.slice(i, i + concurrency);
      
      const batchPromises = batch.map(async (update, index) => {
        try {
          // Add delay between updates to avoid rate limiting
          if (delayBetweenUpdates > 0 && index > 0) {
            await new Promise(resolve => setTimeout(resolve, delayBetweenUpdates));
          }

          const result = await this.updateProperty(
            update.chain,
            update.contractAddress,
            update.tokenId,
            update.propertyName,
            update.value,
            update.options
          );
          
          return {
            success: true,
            update,
            result
          };
        } catch (error) {
          const errorResult = {
            success: false,
            update,
            error: error.message
          };
          
          if (!continueOnError) {
            throw error;
          }
          
          return errorResult;
        }
      });

      const batchResults = await Promise.allSettled(batchPromises);
      
      batchResults.forEach(result => {
        if (result.status === 'fulfilled') {
          if (result.value.success) {
            results.push(result.value);
          } else {
            errors.push(result.value);
          }
        } else {
          errors.push({
            success: false,
            error: result.reason.message
          });
        }
      });
    }

    return {
      successful: results.length,
      failed: errors.length,
      results,
      errors
    };
  }

  validatePropertyUpdate(propertyName, value) {
    const errors = [];
    const warnings = [];

    // Check if property is updatable
    const updatableProperties = ['name', 'description', 'image', 'backgroundColor', 'externalUrl'];
    if (!updatableProperties.includes(propertyName)) {
      errors.push(`Property '${propertyName}' is not updatable. Allowed properties: ${updatableProperties.join(', ')}`);
    }

    // Validate value based on property type
    switch (propertyName) {
      case 'name':
      case 'description':
        if (typeof value !== 'string') {
          errors.push(`${propertyName} must be a string`);
        }
        if (value.length === 0) {
          warnings.push(`${propertyName} is empty`);
        }
        if (value.length > 1000) {
          warnings.push(`${propertyName} is very long (${value.length} characters)`);
        }
        break;

      case 'image':
      case 'externalUrl':
        if (typeof value !== 'string') {
          errors.push(`${propertyName} must be a string URL`);
        } else if (!this.isValidUrl(value)) {
          errors.push(`${propertyName} must be a valid URL`);
        }
        break;

      case 'backgroundColor':
        if (typeof value !== 'string') {
          errors.push('backgroundColor must be a string');
        } else if (!this.isValidColor(value)) {
          errors.push('backgroundColor must be a valid color (hex format recommended)');
        }
        break;
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  estimateUpdateImpact(propertyName, value) {
    const impact = {
      level: 'low',
      affectedAreas: [],
      considerations: []
    };

    switch (propertyName) {
      case 'name':
        impact.level = 'high';
        impact.affectedAreas = ['marketplaces', 'wallets', 'search_results'];
        impact.considerations = ['May affect discoverability', 'Update marketplace listings'];
        break;

      case 'description':
        impact.level = 'medium';
        impact.affectedAreas = ['detail_pages', 'metadata_displays'];
        impact.considerations = ['Update marketing materials if needed'];
        break;

      case 'image':
        impact.level = 'high';
        impact.affectedAreas = ['visual_displays', 'thumbnails', 'galleries'];
        impact.considerations = ['Ensure image is accessible', 'Consider caching delays'];
        break;

      case 'backgroundColor':
        impact.level = 'low';
        impact.affectedAreas = ['visual_styling'];
        impact.considerations = ['May affect visual presentation'];
        break;

      case 'externalUrl':
        impact.level = 'low';
        impact.affectedAreas = ['external_links'];
        impact.considerations = ['Ensure URL is accessible'];
        break;
    }

    return impact;
  }

  recordPropertyChange(nftKey, propertyName, oldValue, newValue, reason) {
    if (!this.changeTracking.has(nftKey)) {
      this.changeTracking.set(nftKey, []);
    }
    
    const changes = this.changeTracking.get(nftKey);
    changes.push({
      timestamp: new Date().toISOString(),
      propertyName,
      oldValue,
      newValue,
      reason,
      impact: this.estimateUpdateImpact(propertyName, newValue)
    });
    
    // Keep only last 50 changes
    if (changes.length > 50) {
      changes.shift();
    }
  }

  getChangeHistory(chain, contractAddress, tokenId) {
    const nftKey = `${chain}:${contractAddress}:${tokenId}`;
    return this.changeTracking.get(nftKey) || [];
  }

  async schedulePropertyUpdate(chain, contractAddress, tokenId, propertyName, value, scheduleTime, options = {}) {
    const nftKey = `${chain}:${contractAddress}:${tokenId}`;
    const scheduleId = `${nftKey}:${propertyName}:${Date.now()}`;
    
    const scheduledUpdate = {
      scheduleId,
      chain,
      contractAddress,
      tokenId,
      propertyName,
      value,
      scheduleTime: new Date(scheduleTime),
      options,
      status: 'scheduled',
      createdAt: new Date().toISOString()
    };
    
    this.scheduledUpdates.set(scheduleId, scheduledUpdate);
    
    // Set timeout for execution
    const delay = new Date(scheduleTime).getTime() - Date.now();
    if (delay > 0) {
      setTimeout(async () => {
        await this.executeScheduledUpdate(scheduleId);
      }, delay);
    }
    
    return scheduleId;
  }

  async executeScheduledUpdate(scheduleId) {
    const scheduledUpdate = this.scheduledUpdates.get(scheduleId);
    
    if (!scheduledUpdate || scheduledUpdate.status !== 'scheduled') {
      return;
    }
    
    try {
      scheduledUpdate.status = 'executing';
      
      const result = await this.updateProperty(
        scheduledUpdate.chain,
        scheduledUpdate.contractAddress,
        scheduledUpdate.tokenId,
        scheduledUpdate.propertyName,
        scheduledUpdate.value,
        scheduledUpdate.options
      );
      
      scheduledUpdate.status = 'completed';
      scheduledUpdate.result = result;
      scheduledUpdate.executedAt = new Date().toISOString();
      
      console.log(`Scheduled update ${scheduleId} completed successfully`);
    } catch (error) {
      scheduledUpdate.status = 'failed';
      scheduledUpdate.error = error.message;
      scheduledUpdate.executedAt = new Date().toISOString();
      
      console.error(`Scheduled update ${scheduleId} failed:`, error);
    }
  }

  async createDynamicNFTSequence(chain, contractAddress, tokenId, sequence, options = {}) {
    const {
      intervalMs = 60000, // 1 minute default
      startDelay = 0
    } = options;

    const sequenceId = `${chain}:${contractAddress}:${tokenId}:sequence:${Date.now()}`;
    const scheduleIds = [];

    for (let i = 0; i < sequence.length; i++) {
      const step = sequence[i];
      const scheduleTime = new Date(Date.now() + startDelay + (i * intervalMs));
      
      const scheduleId = await this.schedulePropertyUpdate(
        chain,
        contractAddress,
        tokenId,
        step.propertyName,
        step.value,
        scheduleTime,
        {
          ...step.options,
          reason: `Sequence ${sequenceId} step ${i + 1}`
        }
      );
      
      scheduleIds.push(scheduleId);
    }

    return {
      sequenceId,
      scheduleIds,
      totalSteps: sequence.length,
      startTime: new Date(Date.now() + startDelay).toISOString(),
      estimatedEndTime: new Date(Date.now() + startDelay + (sequence.length * intervalMs)).toISOString()
    };
  }

  async revertPropertyChange(chain, contractAddress, tokenId, propertyName) {
    const nftKey = `${chain}:${contractAddress}:${tokenId}`;
    const changes = this.getChangeHistory(chain, contractAddress, tokenId);
    
    // Find the last change for this property
    const lastChange = changes
      .filter(change => change.propertyName === propertyName)
      .pop();
    
    if (!lastChange) {
      throw new Error(`No previous change found for property ${propertyName}`);
    }
    
    // Revert to the old value
    return await this.updateProperty(
      chain,
      contractAddress,
      tokenId,
      propertyName,
      lastChange.oldValue,
      {
        reason: `Revert change from ${lastChange.timestamp}`,
        trackChanges: true
      }
    );
  }

  // Utility methods
  isValidUrl(url) {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  isValidColor(color) {
    // Check for hex color format
    const hexPattern = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    if (hexPattern.test(color)) return true;
    
    // Check for named colors (basic validation)
    const namedColors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'pink', 'brown', 'black', 'white', 'gray', 'grey'];
    if (namedColors.includes(color.toLowerCase())) return true;
    
    // Check for rgb/rgba format
    const rgbPattern = /^rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(,\s*[\d.]+)?\s*\)$/;
    return rgbPattern.test(color);
  }

  async getCurrentMetadata(chain, contractAddress, tokenId) {
    // This would typically call the retrieve NFT metadata endpoint
    // For now, return a placeholder
    return {
      name: 'Current Name',
      description: 'Current Description',
      image: 'https://current-image.com/image.png',
      backgroundColor: '#ffffff',
      externalUrl: 'https://current-external.com'
    };
  }

  generateUpdateReport(chain, contractAddress, tokenId) {
    const nftKey = `${chain}:${contractAddress}:${tokenId}`;
    const changes = this.getChangeHistory(chain, contractAddress, tokenId);
    
    const propertyStats = {};
    changes.forEach(change => {
      if (!propertyStats[change.propertyName]) {
        propertyStats[change.propertyName] = 0;
      }
      propertyStats[change.propertyName]++;
    });
    
    return {
      chain,
      contractAddress,
      tokenId,
      totalChanges: changes.length,
      lastUpdate: changes.length > 0 ? changes[changes.length - 1].timestamp : null,
      propertyStats,
      changeHistory: changes.map(change => ({
        timestamp: change.timestamp,
        propertyName: change.propertyName,
        reason: change.reason,
        impact: change.impact
      }))
    };
  }

  clearHistory(chain, contractAddress, tokenId) {
    const nftKey = `${chain}:${contractAddress}:${tokenId}`;
    this.changeTracking.delete(nftKey);
  }
}

// Usage examples
const dynamicNFTManager = new DynamicNFTManager('YOUR_API_KEY');

// Simple property update
const result = await dynamicNFTManager.updateProperty(
  'MATIC',
  '0x127653794299145470e973cf68da9983f576f266',
  3,
  'description',
  'The description of the NFT has been updated.',
  {
    validateBeforeUpdate: true,
    trackChanges: true,
    reason: 'User requested update'
  }
);

console.log('Update result:', result);

// Dry run to test update
const dryRunResult = await dynamicNFTManager.updateProperty(
  'MATIC',
  '0x127653794299145470e973cf68da9983f576f266',
  3,
  'name',
  'New NFT Name',
  { dryRun: true }
);

console.log('Dry run result:', dryRunResult);

// Batch update multiple properties
const batchUpdates = [
  {
    chain: 'MATIC',
    contractAddress: '0x127653794299145470e973cf68da9983f576f266',
    tokenId: 3,
    propertyName: 'name',
    value: 'Updated Name'
  },
  {
    chain: 'MATIC',
    contractAddress: '0x127653794299145470e973cf68da9983f576f266',
    tokenId: 3,
    propertyName: 'backgroundColor',
    value: '#ff0000'
  }
];

const batchResult = await dynamicNFTManager.batchUpdateProperties(batchUpdates);
console.log('Batch update result:', batchResult);

// Schedule a future update
const scheduleId = await dynamicNFTManager.schedulePropertyUpdate(
  'MATIC',
  '0x127653794299145470e973cf68da9983f576f266',
  3,
  'description',
  'Scheduled update description',
  new Date(Date.now() + 3600000) // 1 hour from now
);

console.log('Scheduled update ID:', scheduleId);

// Create a dynamic sequence
const sequence = [
  { propertyName: 'backgroundColor', value: '#ff0000' },
  { propertyName: 'backgroundColor', value: '#00ff00' },
  { propertyName: 'backgroundColor', value: '#0000ff' },
  { propertyName: 'description', value: 'Sequence complete!' }
];

const sequenceResult = await dynamicNFTManager.createDynamicNFTSequence(
  'MATIC',
  '0x127653794299145470e973cf68da9983f576f266',
  3,
  sequence,
  { intervalMs: 30000 } // 30 seconds between updates
);

console.log('Dynamic sequence created:', sequenceResult);

// Get change history
const history = dynamicNFTManager.getChangeHistory(
  'MATIC',
  '0x127653794299145470e973cf68da9983f576f266',
  3
);

console.log('Change history:', history);

// Generate update report
const report = dynamicNFTManager.generateUpdateReport(
  'MATIC',
  '0x127653794299145470e973cf68da9983f576f266',
  3
);

console.log('Update report:', report);
```

```python Python
import requests
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from urllib.parse import urlparse
import re

class DynamicNFTManager:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = '/api/v3/erc1155'
        self.change_tracking = {}
        self.scheduled_updates = {}
    
    def update_nft_property(self, chain: str, contract_address: str, token_id: int,
                           property_name: str, value: str) -> Dict[str, Any]:
        """Update NFT metadata property"""
        url = f'{self.base_url}/contracts/{chain}/{contract_address}/tokens/{token_id}/metadata/{property_name}'
        headers = {
            'Authorization': f'Bearer {self.api_key}',
            'Content-Type': 'application/json'
        }
        
        try:
            response = requests.put(url, headers=headers, json={'value': value})
            response.raise_for_status()
            
            data = response.json()
            
            if data.get('success'):
                return data['result']
            else:
                raise Exception('Failed to update NFT property')
                
        except requests.exceptions.RequestException as error:
            print(f'Error updating NFT property: {error}')
            raise error
    
    def update_property(self, chain: str, contract_address: str, token_id: int,
                       property_name: str, value: str, options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Update property with validation and tracking"""
        if options is None:
            options = {}
        
        validate_before_update = options.get('validate_before_update', True)
        track_changes = options.get('track_changes', True)
        dry_run = options.get('dry_run', False)
        reason = options.get('reason')
        
        nft_key = f"{chain}:{contract_address}:{token_id}"
        
        try:
            # Validate property and value
            if validate_before_update:
                validation = self.validate_property_update(property_name, value)
                if not validation['is_valid']:
                    raise Exception(f"Validation failed: {', '.join(validation['errors'])}")
            
            # Dry run mode
            if dry_run:
                return {
                    'success': True,
                    'dry_run': True,
                    'validation': self.validate_property_update(property_name, value),
                    'estimated_impact': self.estimate_update_impact(property_name, value),
                    'message': 'Dry run completed successfully'
                }
            
            # Get current metadata for comparison
            current_metadata = self.get_current_metadata(chain, contract_address, token_id)
            old_value = current_metadata.get(property_name)
            
            # Execute the update
            result = self.update_nft_property(chain, contract_address, token_id, property_name, value)
            
            # Track changes if requested
            if track_changes:
                self.record_property_change(nft_key, property_name, old_value, value, reason)
            
            return {
                'success': True,
                'result': result,
                'nft_key': nft_key,
                'property_name': property_name,
                'old_value': old_value,
                'new_value': value,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as error:
            print(f'Failed to update {property_name} for NFT {nft_key}: {error}')
            raise error
    
    def batch_update_properties(self, updates: List[Dict[str, Any]], 
                               options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Batch update multiple properties"""
        if options is None:
            options = {}
        
        continue_on_error = options.get('continue_on_error', False)
        validate_all = options.get('validate_all', True)
        delay_between_updates = options.get('delay_between_updates', 1)
        
        results = []
        errors = []
        
        # Validate all updates first if requested
        if validate_all:
            for update in updates:
                validation = self.validate_property_update(update['property_name'], update['value'])
                if not validation['is_valid']:
                    error = {
                        'update': update,
                        'error': f"Validation failed: {', '.join(validation['errors'])}"
                    }
                    
                    if not continue_on_error:
                        raise Exception(f"Batch validation failed: {error['error']}")
                    
                    errors.append(error)
        
        # Process updates
        for i, update in enumerate(updates):
            try:
                # Add delay between updates
                if delay_between_updates > 0 and i > 0:
                    import time
                    time.sleep(delay_between_updates)
                
                result = self.update_property(
                    update['chain'],
                    update['contract_address'],
                    update['token_id'],
                    update['property_name'],
                    update['value'],
                    update.get('options', {})
                )
                
                results.append({
                    'success': True,
                    'update': update,
                    'result': result
                })
                
            except Exception as error:
                error_result = {
                    'success': False,
                    'update': update,
                    'error': str(error)
                }
                
                if not continue_on_error:
                    raise error
                
                errors.append(error_result)
        
        return {
            'successful': len(results),
            'failed': len(errors),
            'results': results,
            'errors': errors
        }
    
    def validate_property_update(self, property_name: str, value: str) -> Dict[str, Any]:
        """Validate property update"""
        errors = []
        warnings = []
        
        # Check if property is updatable
        updatable_properties = ['name', 'description', 'image', 'backgroundColor', 'externalUrl']
        if property_name not in updatable_properties:
            errors.append(f"Property '{property_name}' is not updatable. Allowed properties: {', '.join(updatable_properties)}")
        
        # Validate value based on property type
        if property_name in ['name', 'description']:
            if not isinstance(value, str):
                errors.append(f'{property_name} must be a string')
            elif len(value) == 0:
                warnings.append(f'{property_name} is empty')
            elif len(value) > 1000:
                warnings.append(f'{property_name} is very long ({len(value)} characters)')
        
        elif property_name in ['image', 'externalUrl']:
            if not isinstance(value, str):
                errors.append(f'{property_name} must be a string URL')
            elif not self._is_valid_url(value):
                errors.append(f'{property_name} must be a valid URL')
        
        elif property_name == 'backgroundColor':
            if not isinstance(value, str):
                errors.append('backgroundColor must be a string')
            elif not self._is_valid_color(value):
                errors.append('backgroundColor must be a valid color (hex format recommended)')
        
        return {
            'is_valid': len(errors) == 0,
            'errors': errors,
            'warnings': warnings
        }
    
    def estimate_update_impact(self, property_name: str, value: str) -> Dict[str, Any]:
        """Estimate the impact of the update"""
        impact = {
            'level': 'low',
            'affected_areas': [],
            'considerations': []
        }
        
        if property_name == 'name':
            impact['level'] = 'high'
            impact['affected_areas'] = ['marketplaces', 'wallets', 'search_results']
            impact['considerations'] = ['May affect discoverability', 'Update marketplace listings']
        elif property_name == 'description':
            impact['level'] = 'medium'
            impact['affected_areas'] = ['detail_pages', 'metadata_displays']
            impact['considerations'] = ['Update marketing materials if needed']
        elif property_name == 'image':
            impact['level'] = 'high'
            impact['affected_areas'] = ['visual_displays', 'thumbnails', 'galleries']
            impact['considerations'] = ['Ensure image is accessible', 'Consider caching delays']
        elif property_name == 'backgroundColor':
            impact['level'] = 'low'
            impact['affected_areas'] = ['visual_styling']
            impact['considerations'] = ['May affect visual presentation']
        elif property_name == 'externalUrl':
            impact['level'] = 'low'
            impact['affected_areas'] = ['external_links']
            impact['considerations'] = ['Ensure URL is accessible']
        
        return impact
    
    def record_property_change(self, nft_key: str, property_name: str, old_value: str, 
                              new_value: str, reason: str = None):
        """Record property change for tracking"""
        if nft_key not in self.change_tracking:
            self.change_tracking[nft_key] = []
        
        changes = self.change_tracking[nft_key]
        changes.append({
            'timestamp': datetime.now().isoformat(),
            'property_name': property_name,
            'old_value': old_value,
            'new_value': new_value,
            'reason': reason,
            'impact': self.estimate_update_impact(property_name, new_value)
        })
        
        # Keep only last 50 changes
        if len(changes) > 50:
            self.change_tracking[nft_key] = changes[-50:]
    
    def get_change_history(self, chain: str, contract_address: str, token_id: int) -> List[Dict[str, Any]]:
        """Get change history for NFT"""
        nft_key = f"{chain}:{contract_address}:{token_id}"
        return self.change_tracking.get(nft_key, [])
    
    def get_current_metadata(self, chain: str, contract_address: str, token_id: int) -> Dict[str, Any]:
        """Get current metadata (placeholder implementation)"""
        return {
            'name': 'Current Name',
            'description': 'Current Description',
            'image': 'https://current-image.com/image.png',
            'backgroundColor': '#ffffff',
            'externalUrl': 'https://current-external.com'
        }
    
    def _is_valid_url(self, url: str) -> bool:
        """Check if URL is valid"""
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc])
        except:
            return False
    
    def _is_valid_color(self, color: str) -> bool:
        """Check if color is valid"""
        # Check for hex color format
        hex_pattern = r'^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$'
        if re.match(hex_pattern, color):
            return True
        
        # Check for named colors
        named_colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'pink', 'brown', 'black', 'white', 'gray', 'grey']
        if color.lower() in named_colors:
            return True
        
        # Check for rgb/rgba format
        rgb_pattern = r'^rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(,\s*[\d.]+)?\s*\)$'
        return bool(re.match(rgb_pattern, color))

# Usage
dynamic_nft_manager = DynamicNFTManager('YOUR_API_KEY')

# Simple property update
result = dynamic_nft_manager.update_property(
    'MATIC',
    '0x127653794299145470e973cf68da9983f576f266',
    3,
    'description',
    'The description of the NFT has been updated.',
    {
        'validate_before_update': True,
        'track_changes': True,
        'reason': 'User requested update'
    }
)

print('Update result:', result)
```

```bash cURL
# Update NFT property
curl -X PUT '/api/v3/erc1155/contracts/MATIC/0x127653794299145470e973cf68da9983f576f266/tokens/3/metadata/description' \
  -H 'Authorization: Bearer YOUR_API_KEY' \
  -H 'Content-Type: application/json' \
  -d '{
    "value": "Updated NFT description with new information"
  }'

# Update NFT name
curl -X PUT '/api/v3/erc1155/contracts/MATIC/0x127653794299145470e973cf68da9983f576f266/tokens/3/metadata/name' \
  -H 'Authorization: Bearer YOUR_API_KEY' \
  -H 'Content-Type: application/json' \
  -d '{
    "value": "New NFT Name"
  }'

# Update NFT image
curl -X PUT '/api/v3/erc1155/contracts/MATIC/0x127653794299145470e973cf68da9983f576f266/tokens/3/metadata/image' \
  -H 'Authorization: Bearer YOUR_API_KEY' \
  -H 'Content-Type: application/json' \
  -d '{
    "value": "https://new-image-url.com/updated-image.png"
  }'

# Update background color
curl -X PUT '/api/v3/erc1155/contracts/MATIC/0x127653794299145470e973cf68da9983f576f266/tokens/3/metadata/backgroundColor' \
  -H 'Authorization: Bearer YOUR_API_KEY' \
  -H 'Content-Type: application/json' \
  -d '{
    "value": "#ff6b35"
  }'

# Batch update script
#!/bin/bash
CONTRACT_ADDRESS="0x127653794299145470e973cf68da9983f576f266"
CHAIN="MATIC"
TOKEN_ID="3"

# Array of property updates
declare -A UPDATES=(
  ["name"]="Updated NFT Name"
  ["description"]="Updated description with enhanced details"
  ["backgroundColor"]="#4a90e2"
  ["externalUrl"]="https://updated-external-link.com"
)

for property in "${!UPDATES[@]}"; do
  echo "Updating $property..."
  
  curl -X PUT "/api/v3/erc1155/contracts/$CHAIN/$CONTRACT_ADDRESS/tokens/$TOKEN_ID/metadata/$property" \
    -H 'Authorization: Bearer YOUR_API_KEY' \
    -H 'Content-Type: application/json' \
    -d "{\"value\": \"${UPDATES[$property]}\"}" \
    -s | jq '.success'
  
  echo "Updated $property successfully"
  sleep 1  # Rate limiting
done
```

```php PHP
<?php
class DynamicNFTManager {
    private $apiKey;
    private $baseUrl;
    private $changeTracking;
    
    public function __construct($apiKey, $baseUrl = '/api/v3/erc1155') {
        $this->apiKey = $apiKey;
        $this->baseUrl = $baseUrl;
        $this->changeTracking = [];
    }
    
    public function updateProperty($chain, $contractAddress, $tokenId, $propertyName, $value, $options = []) {
        $validateBeforeUpdate = $options['validateBeforeUpdate'] ?? true;
        $trackChanges = $options['trackChanges'] ?? true;
        $dryRun = $options['dryRun'] ?? false;
        $reason = $options['reason'] ?? null;
        
        $nftKey = "{$chain}:{$contractAddress}:{$tokenId}";
        
        try {
            // Validate property and value
            if ($validateBeforeUpdate) {
                $validation = $this->validatePropertyUpdate($propertyName, $value);
                if (!$validation['isValid']) {
                    throw new Exception('Validation failed: ' . implode(', ', $validation['errors']));
                }
            }
            
            // Dry run mode
            if ($dryRun) {
                return [
                    'success' => true,
                    'dryRun' => true,
                    'validation' => $this->validatePropertyUpdate($propertyName, $value),
                    'estimatedImpact' => $this->estimateUpdateImpact($propertyName, $value),
                    'message' => 'Dry run completed successfully'
                ];
            }
            
            // Get current metadata for comparison
            $currentMetadata = $this->getCurrentMetadata($chain, $contractAddress, $tokenId);
            $oldValue = $currentMetadata[$propertyName] ?? null;
            
            // Execute the update
            $result = $this->updateNFTProperty($chain, $contractAddress, $tokenId, $propertyName, $value);
            
            // Track changes if requested
            if ($trackChanges) {
                $this->recordPropertyChange($nftKey, $propertyName, $oldValue, $value, $reason);
            }
            
            return [
                'success' => true,
                'result' => $result,
                'nftKey' => $nftKey,
                'propertyName' => $propertyName,
                'oldValue' => $oldValue,
                'newValue' => $value,
                'timestamp' => date('c')
            ];
            
        } catch (Exception $error) {
            echo "Failed to update {$propertyName} for NFT {$nftKey}: " . $error->getMessage() . "\n";
            throw $error;
        }
    }
    
    private function updateNFTProperty($chain, $contractAddress, $tokenId, $propertyName, $value) {
        $url = "{$this->baseUrl}/contracts/{$chain}/{$contractAddress}/tokens/{$tokenId}/metadata/{$propertyName}";
        
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            "Authorization: Bearer {$this->apiKey}",
            'Content-Type: application/json'
        ]);
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode(['value' => $value]));
        
        $response = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);
        
        if ($httpCode !== 200) {
            throw new Exception("HTTP {$httpCode}: Failed to update NFT property");
        }
        
        $data = json_decode($response, true);
        
        if (!$data['success']) {
            throw new Exception('Failed to update NFT property');
        }
        
        return $data['result'];
    }
    
    public function validatePropertyUpdate($propertyName, $value) {
        $errors = [];
        $warnings = [];
        
        // Check if property is updatable
        $updatableProperties = ['name', 'description', 'image', 'backgroundColor', 'externalUrl'];
        if (!in_array($propertyName, $updatableProperties)) {
            $errors[] = "Property '{$propertyName}' is not updatable. Allowed properties: " . implode(', ', $updatableProperties);
        }
        
        // Validate value based on property type
        switch ($propertyName) {
            case 'name':
            case 'description':
                if (!is_string($value)) {
                    $errors[] = "{$propertyName} must be a string";
                } elseif (empty($value)) {
                    $warnings[] = "{$propertyName} is empty";
                } elseif (strlen($value) > 1000) {
                    $warnings[] = "{$propertyName} is very long (" . strlen($value) . " characters)";
                }
                break;
                
            case 'image':
            case 'externalUrl':
                if (!is_string($value)) {
                    $errors[] = "{$propertyName} must be a string URL";
                } elseif (!filter_var($value, FILTER_VALIDATE_URL)) {
                    $errors[] = "{$propertyName} must be a valid URL";
                }
                break;
                
            case 'backgroundColor':
                if (!is_string($value)) {
                    $errors[] = 'backgroundColor must be a string';
                } elseif (!$this->isValidColor($value)) {
                    $errors[] = 'backgroundColor must be a valid color (hex format recommended)';
                }
                break;
        }
        
        return [
            'isValid' => empty($errors),
            'errors' => $errors,
            'warnings' => $warnings
        ];
    }
    
    private function estimateUpdateImpact($propertyName, $value) {
        $impact = [
            'level' => 'low',
            'affectedAreas' => [],
            'considerations' => []
        ];
        
        switch ($propertyName) {
            case 'name':
                $impact['level'] = 'high';
                $impact['affectedAreas'] = ['marketplaces', 'wallets', 'search_results'];
                $impact['considerations'] = ['May affect discoverability', 'Update marketplace listings'];
                break;
                
            case 'description':
                $impact['level'] = 'medium';
                $impact['affectedAreas'] = ['detail_pages', 'metadata_displays'];
                $impact['considerations'] = ['Update marketing materials if needed'];
                break;
                
            case 'image':
                $impact['level'] = 'high';
                $impact['affectedAreas'] = ['visual_displays', 'thumbnails', 'galleries'];
                $impact['considerations'] = ['Ensure image is accessible', 'Consider caching delays'];
                break;
                
            case 'backgroundColor':
                $impact['level'] = 'low';
                $impact['affectedAreas'] = ['visual_styling'];
                $impact['considerations'] = ['May affect visual presentation'];
                break;
                
            case 'externalUrl':
                $impact['level'] = 'low';
                $impact['affectedAreas'] = ['external_links'];
                $impact['considerations'] = ['Ensure URL is accessible'];
                break;
        }
        
        return $impact;
    }
    
    private function recordPropertyChange($nftKey, $propertyName, $oldValue, $newValue, $reason) {
        if (!isset($this->changeTracking[$nftKey])) {
            $this->changeTracking[$nftKey] = [];
        }
        
        $this->changeTracking[$nftKey][] = [
            'timestamp' => date('c'),
            'propertyName' => $propertyName,
            'oldValue' => $oldValue,
            'newValue' => $newValue,
            'reason' => $reason,
            'impact' => $this->estimateUpdateImpact($propertyName, $newValue)
        ];
        
        // Keep only last 50 changes
        if (count($this->changeTracking[$nftKey]) > 50) {
            $this->changeTracking[$nftKey] = array_slice($this->changeTracking[$nftKey], -50);
        }
    }
    
    public function getChangeHistory($chain, $contractAddress, $tokenId) {
        $nftKey = "{$chain}:{$contractAddress}:{$tokenId}";
        return $this->changeTracking[$nftKey] ?? [];
    }
    
    private function getCurrentMetadata($chain, $contractAddress, $tokenId) {
        // Placeholder implementation
        return [
            'name' => 'Current Name',
            'description' => 'Current Description',
            'image' => 'https://current-image.com/image.png',
            'backgroundColor' => '#ffffff',
            'externalUrl' => 'https://current-external.com'
        ];
    }
    
    private function isValidColor($color) {
        // Check for hex color format
        if (preg_match('/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/', $color)) {
            return true;
        }
        
        // Check for named colors
        $namedColors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'pink', 'brown', 'black', 'white', 'gray', 'grey'];
        if (in_array(strtolower($color), $namedColors)) {
            return true;
        }
        
        // Check for rgb/rgba format
        if (preg_match('/^rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(,\s*[\d.]+)?\s*\)$/', $color)) {
            return true;
        }
        
        return false;
    }
    
    public function batchUpdateProperties($updates, $options = []) {
        $continueOnError = $options['continueOnError'] ?? false;
        $validateAll = $options['validateAll'] ?? true;
        $delayBetweenUpdates = $options['delayBetweenUpdates'] ?? 1;
        
        $results = [];
        $errors = [];
        
        // Validate all updates first if requested
        if ($validateAll) {
            foreach ($updates as $update) {
                $validation = $this->validatePropertyUpdate($update['propertyName'], $update['value']);
                if (!$validation['isValid']) {
                    $error = [
                        'update' => $update,
                        'error' => 'Validation failed: ' . implode(', ', $validation['errors'])
                    ];
                    
                    if (!$continueOnError) {
                        throw new Exception('Batch validation failed: ' . $error['error']);
                    }
                    
                    $errors[] = $error;
                }
            }
        }
        
        // Process updates
        foreach ($updates as $i => $update) {
            try {
                // Add delay between updates
                if ($delayBetweenUpdates > 0 && $i > 0) {
                    sleep($delayBetweenUpdates);
                }
                
                $result = $this->updateProperty(
                    $update['chain'],
                    $update['contractAddress'],
                    $update['tokenId'],
                    $update['propertyName'],
                    $update['value'],
                    $update['options'] ?? []
                );
                
                $results[] = [
                    'success' => true,
                    'update' => $update,
                    'result' => $result
                ];
                
            } catch (Exception $error) {
                $errorResult = [
                    'success' => false,
                    'update' => $update,
                    'error' => $error->getMessage()
                ];
                
                if (!$continueOnError) {
                    throw $error;
                }
                
                $errors[] = $errorResult;
            }
        }
        
        return [
            'successful' => count($results),
            'failed' => count($errors),
            'results' => $results,
            'errors' => $errors
        ];
    }
    
    public function generateUpdateReport($chain, $contractAddress, $tokenId) {
        $nftKey = "{$chain}:{$contractAddress}:{$tokenId}";
        $changes = $this->getChangeHistory($chain, $contractAddress, $tokenId);
        
        $propertyStats = [];
        foreach ($changes as $change) {
            $propertyName = $change['propertyName'];
            if (!isset($propertyStats[$propertyName])) {
                $propertyStats[$propertyName] = 0;
            }
            $propertyStats[$propertyName]++;
        }
        
        return [
            'chain' => $chain,
            'contractAddress' => $contractAddress,
            'tokenId' => $tokenId,
            'totalChanges' => count($changes),
            'lastUpdate' => !empty($changes) ? end($changes)['timestamp'] : null,
            'propertyStats' => $propertyStats,
            'changeHistory' => array_map(function($change) {
                return [
                    'timestamp' => $change['timestamp'],
                    'propertyName' => $change['propertyName'],
                    'reason' => $change['reason'],
                    'impact' => $change['impact']
                ];
            }, $changes)
        ];
    }
}

// Usage
$dynamicNFTManager = new DynamicNFTManager('YOUR_API_KEY');

try {
    // Simple property update
    $result = $dynamicNFTManager->updateProperty(
        'MATIC',
        '0x127653794299145470e973cf68da9983f576f266',
        3,
        'description',
        'The description of the NFT has been updated.',
        [
            'validateBeforeUpdate' => true,
            'trackChanges' => true,
            'reason' => 'User requested update'
        ]
    );
    
    echo "Update result: " . json_encode($result, JSON_PRETTY_PRINT) . "\n";
    
    // Batch update
    $batchUpdates = [
        [
            'chain' => 'MATIC',
            'contractAddress' => '0x127653794299145470e973cf68da9983f576f266',
            'tokenId' => 3,
            'propertyName' => 'name',
            'value' => 'Updated Name'
        ],
        [
            'chain' => 'MATIC',
            'contractAddress' => '0x127653794299145470e973cf68da9983f576f266',
            'tokenId' => 3,
            'propertyName' => 'backgroundColor',
            'value' => '#ff0000'
        ]
    ];
    
    $batchResult = $dynamicNFTManager->batchUpdateProperties($batchUpdates);
    echo "Batch update result: " . json_encode($batchResult, JSON_PRETTY_PRINT) . "\n";
    
} catch (Exception $e) {
    echo "Error: " . $e->getMessage() . "\n";
}
?>
```
</CodeGroup>

## Best Practices

<Tip>
**Dynamic NFT Update Best Practices:**

1. **Plan Dynamic Elements** - Design updatable properties from the start of your NFT project
2. **Validate All Changes** - Always validate property values before updating to prevent errors
3. **Track Changes** - Maintain a history of updates for transparency and debugging
4. **Communicate Updates** - Notify NFT holders about significant changes to their assets
5. **Test Updates** - Use dry run mode to test updates before applying them
6. **Consider Impact** - Understand how updates affect marketplaces, wallets, and user experience
7. **Batch Operations** - Use batch updates for efficiency when updating multiple properties
8. **Access Control** - Implement proper permissions for who can update NFT properties
</Tip>

## What's Next?

<CardGroup cols={2}>
  <Card title="Retrieve NFT Metadata" href="/guides/nft-api/metadata/retrieve-nft-metadata" icon="search">
    Learn how to retrieve individual NFT metadata
  </Card>
  <Card title="Token Type Metadata" href="/guides/nft-api/metadata/update-token-type-metadata" icon="layer-group">
    Update token type metadata templates
  </Card>
  <Card title="NFT Querying" href="/guides/nft-api/querying/retrieve-nft-details" icon="magnifying-glass">
    Advanced NFT querying and filtering
  </Card>
  <Card title="API Reference" href="/api-reference/NFT-API/token-metadata/update-property" icon="book">
    Explore the complete NFT metadata update API documentation
  </Card>
</CardGroup>
