---
title: "Update ERC20 Contract Owner"
description: "Transfer ownership of your ERC20 token contracts to new wallet addresses with secure ownership management"
icon: "crown"
---

<Info>
**Contract Ownership Transfer:** Securely transfer administrative control of your ERC20 token contracts to new owners.

**Time required:** ~10 minutes
</Info>

## What is Contract Ownership Transfer?

Contract ownership transfer allows you to change the owner of an ERC20 token contract. The new owner will have full administrative rights, including the ability to mint tokens, update contract settings, and transfer ownership again.

<CardGroup cols={2}>
  <Card title="Administrative Control" icon="shield">
    Transfer full contract control to new owner
  </Card>
  <Card title="Secure Process" icon="lock">
    Blockchain-verified ownership transfer
  </Card>
  <Card title="Immediate Effect" icon="bolt">
    Ownership changes take effect immediately
  </Card>
  <Card title="Irreversible Action" icon="exclamation-triangle">
    Cannot be undone without new owner's consent
  </Card>
</CardGroup>

## Why Transfer Ownership?

<Tabs>
  <Tab title="Business Scenarios">
    **Common Use Cases**
    - Company acquisition or merger
    - Team member changes
    - Organizational restructuring
    - Decentralization initiatives
  </Tab>
  <Tab title="Technical Reasons">
    **System Requirements**
    - Multi-signature wallet setup
    - Smart contract upgrades
    - Security improvements
    - Automated management systems
  </Tab>
  <Tab title="Governance">
    **Decentralized Control**
    - DAO governance implementation
    - Community ownership transfer
    - Trustless management
    - Distributed decision making
  </Tab>
</Tabs>

## Prerequisites

<Steps>
  <Step title="Contract Ownership" icon="crown">
    You must be the current owner of the ERC20 contract
  </Step>
  <Step title="New Owner Address" icon="wallet">
    Valid wallet address for the new owner
  </Step>
  <Step title="Contract Information" icon="info">
    Chain and contract address details
  </Step>
  <Step title="Verification" icon="check">
    Confirm the new owner can accept ownership
  </Step>
</Steps>

<Warning>
**Critical Warning:** Ownership transfer is immediate and irreversible. Ensure the new owner address is correct and that the recipient can manage the contract properly.
</Warning>

## Update Contract Owner

### API Endpoint

<CodeGroup>
```javascript JavaScript
const chain = "MATIC";
const contractAddress = "0x49b37698bdcc75afa99e319c0b7d803e732a9d85";
const newOwner = "0xf2b1cEB69E765469a80E8d4c8635B05269889fa7";

const response = await fetch(`/api/v3/erc20/contracts/${chain}/${contractAddress}/owner`, {
  method: 'PUT',
  headers: {
    'Authorization': 'Bearer YOUR_API_KEY',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    owner: newOwner
  })
});

const data = await response.json();
console.log('Ownership transfer transaction:', data.result.transactionHash);
```

```python Python
import requests

chain = "MATIC"
contract_address = "0x49b37698bdcc75afa99e319c0b7d803e732a9d85"
new_owner = "0xf2b1cEB69E765469a80E8d4c8635B05269889fa7"

response = requests.put(
    f'/api/v3/erc20/contracts/{chain}/{contract_address}/owner',
    headers={
        'Authorization': 'Bearer YOUR_API_KEY',
        'Content-Type': 'application/json'
    },
    json={'owner': new_owner}
)

data = response.json()
print('Ownership transfer transaction:', data['result']['transactionHash'])
```

```bash cURL
curl -X PUT '/api/v3/erc20/contracts/MATIC/0x49b37698bdcc75afa99e319c0b7d803e732a9d85/owner' \
  -H 'Authorization: Bearer YOUR_API_KEY' \
  -H 'Content-Type: application/json' \
  -d '{
    "owner": "0xf2b1cEB69E765469a80E8d4c8635B05269889fa7"
  }'
```
</CodeGroup>

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `chain` | string | ✅ | Blockchain identifier (MATIC, ETHEREUM, etc.) |
| `contractAddress` | string | ✅ | ERC20 contract address |
| `owner` | string | ✅ | New owner's wallet address |

<Tip>
**Address Validation:** Always double-check the new owner address. Consider using address validation tools or checksums to prevent errors.
</Tip>

### Response Example

<Tabs>
  <Tab title="Success Response">
    ```json
    {
      "success": true,
      "result": {
        "transactionHash": "0x2cb6028946609a8c78e243b24f7a4a21959d8ca772666b5979043dbd6189f84a"
      }
    }
    ```
  </Tab>
  <Tab title="Response Fields">
    **Transaction information:**
    - **`transactionHash`** - Blockchain transaction hash for the ownership transfer
    
    **Verification:**
    - Use the transaction hash to verify the transfer on a blockchain explorer
    - Check that the new owner is correctly set in the contract
  </Tab>
</Tabs>

<Check>
**Verification:** Use the transaction hash to verify the ownership transfer on a blockchain explorer. The new owner should now have full administrative control over the contract.
</Check>

## Ownership Transfer Workflow

<Steps>
  <Step title="Prepare Transfer" icon="clipboard">
    Verify current ownership and prepare new owner details
  </Step>
  <Step title="Validate Address" icon="check-circle">
    Confirm the new owner address is correct and accessible
  </Step>
  <Step title="Execute Transfer" icon="arrow-right">
    Call the API endpoint to transfer ownership
  </Step>
  <Step title="Monitor Transaction" icon="eye">
    Track the blockchain transaction until confirmation
  </Step>
  <Step title="Verify Transfer" icon="shield-check">
    Confirm the new owner has control of the contract
  </Step>
</Steps>

## Advanced Ownership Management

<AccordionGroup>
  <Accordion title="Multi-Signature Ownership" icon="users">
    **Transfer to multi-sig wallets for enhanced security:**
    
    ```javascript
    class MultiSigOwnershipManager {
      constructor(apiKey) {
        this.apiKey = apiKey;
      }
    
      async transferToMultiSig(contractDetails, multiSigAddress, signers) {
        // Validate multi-sig setup
        await this.validateMultiSig(multiSigAddress, signers);
        
        // Prepare ownership transfer
        const transferData = {
          chain: contractDetails.chain,
          contractAddress: contractDetails.address,
          newOwner: multiSigAddress,
          transferType: 'MULTI_SIG',
          requiredSigners: signers.length,
          signerAddresses: signers
        };
        
        // Execute transfer
        const result = await this.executeOwnershipTransfer(transferData);
        
        // Set up multi-sig management
        await this.setupMultiSigManagement(contractDetails, multiSigAddress, signers);
        
        return result;
      }
    
      async validateMultiSig(multiSigAddress, signers) {
        // Verify multi-sig contract exists and is properly configured
        const multiSigInfo = await this.getMultiSigInfo(multiSigAddress);
        
        if (!multiSigInfo.isValid) {
          throw new Error('Invalid multi-signature wallet');
        }
        
        if (multiSigInfo.signers.length !== signers.length) {
          throw new Error('Signer count mismatch');
        }
        
        // Verify all signers are authorized
        for (const signer of signers) {
          if (!multiSigInfo.signers.includes(signer)) {
            throw new Error(`Unauthorized signer: ${signer}`);
          }
        }
        
        return true;
      }
    
      async executeOwnershipTransfer(transferData) {
        const response = await fetch(`/api/v3/erc20/contracts/${transferData.chain}/${transferData.contractAddress}/owner`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            owner: transferData.newOwner
          })
        });
        
        const result = await response.json();
        
        // Log the transfer
        await this.logOwnershipTransfer(transferData, result);
        
        return result;
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Ownership Verification" icon="magnifying-glass">
    **Verify ownership before and after transfer:**
    
    ```javascript
    class OwnershipVerifier {
      constructor(apiKey) {
        this.apiKey = apiKey;
      }
    
      async verifyCurrentOwner(chain, contractAddress) {
        try {
          const response = await fetch(`/api/v3/erc20/contracts/${chain}/${contractAddress}`, {
            headers: { 'Authorization': `Bearer ${this.apiKey}` }
          });
          
          const data = await response.json();
          return {
            currentOwner: data.result.owner,
            contractAddress: data.result.address,
            contractName: data.result.name,
            symbol: data.result.symbol
          };
        } catch (error) {
          throw new Error(`Failed to verify current owner: ${error.message}`);
        }
      }
    
      async verifyOwnershipTransfer(chain, contractAddress, expectedNewOwner, transactionHash) {
        // Wait for transaction confirmation
        await this.waitForTransactionConfirmation(transactionHash);
        
        // Verify new ownership
        const contractInfo = await this.verifyCurrentOwner(chain, contractAddress);
        
        if (contractInfo.currentOwner.toLowerCase() !== expectedNewOwner.toLowerCase()) {
          throw new Error('Ownership transfer verification failed');
        }
        
        return {
          verified: true,
          newOwner: contractInfo.currentOwner,
          transactionHash,
          timestamp: new Date().toISOString()
        };
      }
    
      async waitForTransactionConfirmation(transactionHash, maxAttempts = 30) {
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
          try {
            const confirmed = await this.checkTransactionStatus(transactionHash);
            if (confirmed) {
              console.log(`Transaction confirmed after ${attempt} attempts`);
              return true;
            }
            
            // Wait 10 seconds before next check
            await new Promise(resolve => setTimeout(resolve, 10000));
          } catch (error) {
            console.error(`Attempt ${attempt} failed:`, error.message);
          }
        }
        
        throw new Error('Transaction confirmation timeout');
      }
    
      async checkTransactionStatus(transactionHash) {
        // Implementation depends on blockchain
        // This is a placeholder for actual blockchain query
        console.log(`Checking transaction status: ${transactionHash}`);
        return true; // Simplified for example
      }
    }
    
    // Usage
    const verifier = new OwnershipVerifier('YOUR_API_KEY');
    
    // Before transfer
    const currentOwnership = await verifier.verifyCurrentOwner('MATIC', contractAddress);
    console.log('Current owner:', currentOwnership.currentOwner);
    
    // After transfer
    const verification = await verifier.verifyOwnershipTransfer(
      'MATIC',
      contractAddress,
      newOwnerAddress,
      transactionHash
    );
    console.log('Transfer verified:', verification);
    ```
  </Accordion>
  
  <Accordion title="Batch Ownership Transfer" icon="list">
    **Transfer ownership of multiple contracts:**
    
    ```javascript
    class BatchOwnershipManager {
      constructor(apiKey) {
        this.apiKey = apiKey;
        this.transferQueue = [];
        this.results = [];
      }
    
      addContractToQueue(chain, contractAddress, newOwner, metadata = {}) {
        this.transferQueue.push({
          chain,
          contractAddress,
          newOwner,
          metadata,
          status: 'PENDING'
        });
      }
    
      async executeBatchTransfer(options = {}) {
        const { 
          batchSize = 5, 
          delayBetweenBatches = 30000,
          continueOnError = true 
        } = options;
        
        console.log(`Starting batch transfer of ${this.transferQueue.length} contracts`);
        
        for (let i = 0; i < this.transferQueue.length; i += batchSize) {
          const batch = this.transferQueue.slice(i, i + batchSize);
          
          console.log(`Processing batch ${Math.floor(i / batchSize) + 1}...`);
          
          const batchPromises = batch.map(transfer => 
            this.executeTransfer(transfer).catch(error => ({
              ...transfer,
              error: error.message,
              status: 'FAILED'
            }))
          );
          
          const batchResults = await Promise.all(batchPromises);
          this.results.push(...batchResults);
          
          // Update queue status
          batch.forEach((transfer, index) => {
            transfer.status = batchResults[index].status || 'COMPLETED';
            transfer.result = batchResults[index];
          });
          
          // Delay between batches to avoid rate limiting
          if (i + batchSize < this.transferQueue.length) {
            console.log(`Waiting ${delayBetweenBatches / 1000} seconds before next batch...`);
            await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
          }
        }
        
        return this.generateBatchReport();
      }
    
      async executeTransfer(transfer) {
        try {
          const response = await fetch(`/api/v3/erc20/contracts/${transfer.chain}/${transfer.contractAddress}/owner`, {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${this.apiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              owner: transfer.newOwner
            })
          });
          
          const result = await response.json();
          
          return {
            ...transfer,
            transactionHash: result.result.transactionHash,
            status: 'COMPLETED',
            timestamp: new Date().toISOString()
          };
        } catch (error) {
          throw new Error(`Transfer failed for ${transfer.contractAddress}: ${error.message}`);
        }
      }
    
      generateBatchReport() {
        const successful = this.results.filter(r => r.status === 'COMPLETED');
        const failed = this.results.filter(r => r.status === 'FAILED');
        
        return {
          total: this.results.length,
          successful: successful.length,
          failed: failed.length,
          successRate: (successful.length / this.results.length * 100).toFixed(2),
          results: this.results,
          summary: {
            completedTransfers: successful.map(r => ({
              contract: r.contractAddress,
              newOwner: r.newOwner,
              transactionHash: r.transactionHash
            })),
            failedTransfers: failed.map(r => ({
              contract: r.contractAddress,
              error: r.error
            }))
          }
        };
      }
    }
    
    // Usage
    const batchManager = new BatchOwnershipManager('YOUR_API_KEY');
    
    // Add contracts to transfer queue
    batchManager.addContractToQueue('MATIC', '0x123...', '0xabc...', { project: 'TokenA' });
    batchManager.addContractToQueue('MATIC', '0x456...', '0xdef...', { project: 'TokenB' });
    batchManager.addContractToQueue('ETHEREUM', '0x789...', '0x123...', { project: 'TokenC' });
    
    // Execute batch transfer
    const report = await batchManager.executeBatchTransfer({
      batchSize: 3,
      delayBetweenBatches: 60000,
      continueOnError: true
    });
    
    console.log('Batch transfer report:', report);
    ```
  </Accordion>
  
  <Accordion title="Emergency Ownership Recovery" icon="life-ring">
    **Implement emergency ownership recovery procedures:**
    
    ```javascript
    class EmergencyOwnershipRecovery {
      constructor(apiKey) {
        this.apiKey = apiKey;
        this.emergencyContacts = [];
        this.recoveryProcedures = new Map();
      }
    
      setupEmergencyRecovery(contractAddress, config) {
        this.recoveryProcedures.set(contractAddress, {
          backupOwners: config.backupOwners,
          requiredSignatures: config.requiredSignatures,
          timelock: config.timelock || 24 * 60 * 60 * 1000, // 24 hours
          emergencyContacts: config.emergencyContacts,
          recoveryConditions: config.recoveryConditions
        });
      }
    
      async initiateEmergencyRecovery(contractAddress, reason, initiator) {
        const procedure = this.recoveryProcedures.get(contractAddress);
        if (!procedure) {
          throw new Error('No emergency recovery procedure configured');
        }
        
        const recoveryRequest = {
          contractAddress,
          reason,
          initiator,
          timestamp: Date.now(),
          status: 'INITIATED',
          approvals: [],
          requiredApprovals: procedure.requiredSignatures
        };
        
        // Notify emergency contacts
        await this.notifyEmergencyContacts(recoveryRequest);
        
        // Start approval process
        return this.startApprovalProcess(recoveryRequest);
      }
    
      async approveRecovery(recoveryId, approver, signature) {
        const recovery = await this.getRecoveryRequest(recoveryId);
        
        // Verify approver is authorized
        const procedure = this.recoveryProcedures.get(recovery.contractAddress);
        if (!procedure.backupOwners.includes(approver)) {
          throw new Error('Unauthorized approver');
        }
        
        // Add approval
        recovery.approvals.push({
          approver,
          signature,
          timestamp: Date.now()
        });
        
        // Check if enough approvals
        if (recovery.approvals.length >= recovery.requiredApprovals) {
          return this.executeEmergencyRecovery(recovery);
        }
        
        return recovery;
      }
    
      async executeEmergencyRecovery(recovery) {
        const procedure = this.recoveryProcedures.get(recovery.contractAddress);
        
        // Check timelock
        const timeSinceInitiation = Date.now() - recovery.timestamp;
        if (timeSinceInitiation < procedure.timelock) {
          throw new Error('Timelock period not yet expired');
        }
        
        // Select new owner (first backup owner by default)
        const newOwner = procedure.backupOwners[0];
        
        // Execute ownership transfer
        const transferResult = await this.executeOwnershipTransfer(
          recovery.contractAddress,
          newOwner
        );
        
        // Log emergency recovery
        await this.logEmergencyRecovery(recovery, transferResult);
        
        return {
          ...recovery,
          status: 'COMPLETED',
          newOwner,
          transactionHash: transferResult.transactionHash,
          completedAt: Date.now()
        };
      }
    
      async notifyEmergencyContacts(recoveryRequest) {
        const notifications = this.emergencyContacts.map(contact => 
          this.sendEmergencyNotification(contact, recoveryRequest)
        );
        
        await Promise.all(notifications);
      }
    }
    ```
  </Accordion>
</AccordionGroup>

## Integration Examples

<Tabs>
  <Tab title="React Component">
    ```javascript
    import React, { useState } from 'react';
    
    function OwnershipTransfer({ contract }) {
      const [newOwner, setNewOwner] = useState('');
      const [loading, setLoading] = useState(false);
      const [result, setResult] = useState(null);
      const [error, setError] = useState(null);
    
      const validateAddress = (address) => {
        const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
        return ethAddressRegex.test(address);
      };
    
      const handleTransfer = async () => {
        if (!validateAddress(newOwner)) {
          setError('Invalid wallet address format');
          return;
        }
    
        setLoading(true);
        setError(null);
    
        try {
          const response = await fetch(`/api/v3/erc20/contracts/${contract.chain}/${contract.address}/owner`, {
            method: 'PUT',
            headers: {
              'Authorization': 'Bearer YOUR_API_KEY',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ owner: newOwner })
          });
    
          const data = await response.json();
          
          if (data.success) {
            setResult(data.result);
            setNewOwner('');
          } else {
            setError('Transfer failed');
          }
        } catch (err) {
          setError(err.message);
        } finally {
          setLoading(false);
        }
      };
    
      return (
        <div className="ownership-transfer">
          <h3>Transfer Contract Ownership</h3>
          
          <div className="contract-info">
            <p><strong>Contract:</strong> {contract.name} ({contract.symbol})</p>
            <p><strong>Current Owner:</strong> {contract.owner}</p>
            <p><strong>Address:</strong> {contract.address}</p>
          </div>
    
          <div className="transfer-form">
            <label>
              New Owner Address:
              <input
                type="text"
                value={newOwner}
                onChange={(e) => setNewOwner(e.target.value)}
                placeholder="0x..."
                disabled={loading}
              />
            </label>
            
            <button 
              onClick={handleTransfer}
              disabled={loading || !newOwner || !validateAddress(newOwner)}
            >
              {loading ? 'Transferring...' : 'Transfer Ownership'}
            </button>
          </div>
    
          {error && (
            <div className="error">
              Error: {error}
            </div>
          )}
    
          {result && (
            <div className="success">
              <h4>Transfer Successful!</h4>
              <p>Transaction Hash: <code>{result.transactionHash}</code></p>
              <p>New owner will have full control of the contract.</p>
            </div>
          )}
        </div>
      );
    }
    ```
  </Tab>
  <Tab title="Express.js API">
    ```javascript
    const express = require('express');
    const app = express();
    
    // Transfer ownership endpoint
    app.put('/api/contracts/:chain/:address/owner', async (req, res) => {
      try {
        const { chain, address } = req.params;
        const { newOwner, currentOwner } = req.body;
        
        // Validate inputs
        if (!isValidAddress(newOwner)) {
          return res.status(400).json({ error: 'Invalid new owner address' });
        }
        
        // Verify current ownership (optional security check)
        if (currentOwner) {
          const contractInfo = await getContractInfo(chain, address);
          if (contractInfo.owner.toLowerCase() !== currentOwner.toLowerCase()) {
            return res.status(403).json({ error: 'Current owner mismatch' });
          }
        }
        
        // Execute ownership transfer
        const response = await fetch(`/api/v3/erc20/contracts/${chain}/${address}/owner`, {
          method: 'PUT',
          headers: {
            'Authorization': 'Bearer YOUR_API_KEY',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ owner: newOwner })
        });
        
        const data = await response.json();
        
        if (data.success) {
          // Log the transfer
          await logOwnershipTransfer({
            chain,
            contractAddress: address,
            previousOwner: currentOwner,
            newOwner,
            transactionHash: data.result.transactionHash,
            timestamp: new Date()
          });
          
          res.json({
            success: true,
            transactionHash: data.result.transactionHash,
            newOwner,
            message: 'Ownership transferred successfully'
          });
        } else {
          res.status(500).json({ error: 'Transfer failed' });
        }
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
    
    // Get ownership history
    app.get('/api/contracts/:chain/:address/ownership-history', async (req, res) => {
      try {
        const { chain, address } = req.params;
        const history = await getOwnershipHistory(chain, address);
        res.json({ history });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
    
    function isValidAddress(address) {
      return /^0x[a-fA-F0-9]{40}$/.test(address);
    }
    ```
  </Tab>
</Tabs>

## Best Practices

<Tip>
**Ownership Transfer Best Practices:**

1. **Double-Check Addresses** - Verify new owner address multiple times
2. **Test on Testnet** - Practice transfers on test networks first
3. **Document Transfers** - Keep records of all ownership changes
4. **Verify Recipients** - Ensure new owners can manage contracts properly
5. **Use Multi-Sig** - Consider multi-signature wallets for enhanced security
6. **Plan Succession** - Have backup ownership plans in place
</Tip>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Transfer failed">
    **Common causes:**
    - Not the current contract owner
    - Invalid new owner address
    - Insufficient gas fees
    - Network connectivity issues
    
    **Solution:** Verify you're the current owner, check the new owner address format, and ensure sufficient gas fees.
  </Accordion>
  
  <Accordion title="Transaction pending">
    **Possible issues:**
    - Network congestion
    - Low gas price
    - Blockchain synchronization delays
    
    **Solution:** Wait for network confirmation or increase gas price for faster processing.
  </Accordion>
  
  <Accordion title="New owner cannot access">
    **Common problems:**
    - Wrong private key or wallet
    - Multi-signature setup issues
    - Smart contract wallet complications
    
    **Solution:** Verify the new owner has proper access to the wallet and understands contract management.
  </Accordion>
  
  <Accordion title="Ownership verification failed">
    **Potential causes:**
    - Transaction not yet confirmed
    - Blockchain explorer delays
    - Caching issues
    
    **Solution:** Wait for transaction confirmation and check multiple blockchain explorers.
  </Accordion>
</AccordionGroup>

## What's Next?

<CardGroup cols={2}>
  <Card title="View Contracts" href="/guides/token-api/contracts/retrieve-erc20-token-contracts" icon="list">
    View all your token contracts and their owners
  </Card>
  <Card title="Mint Tokens" href="/guides/token-api/minting/mint-erc20-tokens" icon="coins">
    Mint tokens with your newly transferred contract
  </Card>
  <Card title="Contract Status" href="/guides/token-api/contracts/check-erc20-token-contract-status" icon="magnifying-glass">
    Monitor contract deployment and status
  </Card>
  <Card title="Set Up Webhooks" href="/guides/token-api/advanced/webhooks-token-api" icon="webhook">
    Get notifications for contract events
  </Card>
</CardGroup>

<Warning>
**Critical Reminder:** Ownership transfer is immediate and irreversible. The new owner will have complete control over the contract, including the ability to mint tokens and transfer ownership again. Ensure you trust the recipient and they understand their responsibilities.
</Warning>
